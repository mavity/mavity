# Error Capture in REPL System

This document describes the error capture mechanism implemented in both the HTTP REPL (docs/7-http-test-harness.md) and File-based REPL (docs/7.1-file-test-harness.md).

## Overview

The REPL system now captures all `window.error` and `unhandledrejection` events that occur during eval execution. These errors are buffered and included in the result payload, providing complete visibility into runtime issues that may occur alongside or independent of the main eval result.

## Client-Side Error Capture

The injected client script (`serve.js` â†’ `inject()`) maintains an error buffer that captures:

1. **Uncaught exceptions** via `window.addEventListener('error', ...)`
2. **Unhandled promise rejections** via `window.addEventListener('unhandledrejection', ...)`

### Error Buffer Lifecycle

- **Reset**: The error buffer is cleared before each eval execution
- **Capture**: All errors occurring during eval are appended to the buffer
- **Transmission**: The complete buffer is sent along with the eval result (success or failure)

### Error Format

Each captured error is converted to its stack trace string:
```javascript
const stack = err?.stack || String(err);
errorBuffer.push(stack);
```

If `stack` is not available, the error is converted to a string representation.

## Server-Side Error Formatting

### HTTP REPL Format

Errors are prepended (for successful results) or appended (for error results) as a multi-line comment block:

**Success with errors:**
```javascript
/*
TypeError: Cannot read property 'x' of undefined
    at <anonymous>:1:5
---
ReferenceError: y is not defined
    at <anonymous>:2:10
---
*/
{"result": "success"}
```

**Failure with errors:**
```
ReferenceError: z is not defined
    at <anonymous>:1:1

/*
TypeError: Cannot read property 'x' of undefined
    at <anonymous>:1:5
---
*/
```

The separator `---` is used between multiple errors.

### File-based REPL Format

Errors appear in the same comment block format at the end of the result body:

**Success with errors:**
```javascript
// index-7-zen-12:01:03 http://localhost:8302/index 09:34:02 completed in 742ms (result below)
// eval result for: (async () => { ... })()
var result = {
  "status": "ok"
}

/*
TypeError: Cannot read property 'x' of undefined
    at <anonymous>:1:5
---
ReferenceError: y is not defined
    at <anonymous>:2:10
---
*/
```

**Failure with errors:**
```javascript
// index-7-zen-12:01:03 http://localhost:8302/index 09:34:10 failed after 1,220ms (see below)
// eval error for: (async () => { ... })()
ReferenceError: z is not defined
    at <anonymous>:1:1
    at ...

/*
TypeError: Cannot read property 'x' of undefined
    at <anonymous>:1:5
---
*/
```

## Special Value Handling

The REPL now provides better context for non-serializable values:

### Functions
```javascript
// eval:
(() => { return function myFunc() {} })()

// result:
var result = "function myFunc() {}"
```

### Undefined
```javascript
// eval:
(() => { return undefined })()

// result:
var result = "undefined"
```

Previously, `undefined` would be serialized as `null`, and functions would fail JSON serialization. Now they are converted to their string representation using `String(value)`, providing more debugging context.

## Implementation Details

### Client (inject function)

```javascript
// Error buffer: capture all window errors since last eval
const errorBuffer = [];
const errorHandler = (event) => {
  const err = event.error || event.reason || { message: event.message || String(event) };
  const stack = err?.stack || String(err);
  errorBuffer.push(stack);
};
window.addEventListener('error', errorHandler);
window.addEventListener('unhandledrejection', errorHandler);

// Before eval
errorBuffer.length = 0;

// After eval
payload = JSON.stringify({ 
  ok: true, 
  value: serializedValue, 
  errors: errorBuffer.slice() 
});
```

### Server (Jobs.complete)

```javascript
const errors = outcome.errors || [];

// HTTP mode - prepend/append comment block
if (errors.length > 0) {
  const errorBlock = '/*\n' + errors.join('\n---\n') + '\n*/\n';
  result = errorBlock + result;  // or append for errors
}

// File mode - pass to formatting functions
FileHarness.finishFileJob(outcome.ok, job.snippet, payload, errors);
```

### Formatting Functions

Both `buildResultBody(value, errors)` and `buildErrorBody(error, errors)` accept an errors array and append it as a comment block:

```javascript
if (errors && errors.length > 0) {
  body.push('');
  body.push('/*');
  for (const err of errors) {
    body.push(String(err));
    body.push('---');
  }
  body.push('*/');
}
```

## Use Cases

### Detecting Side-Effect Errors

When an eval succeeds but triggers background errors:
```javascript
// eval:
(async () => {
  setTimeout(() => { throw new Error('background error'); }, 10);
  await new Promise(r => setTimeout(r, 100));
  return 'success';
})()

// result includes both success and the captured error
```

### Debugging Promise Rejections

Unhandled promise rejections that don't prevent eval completion:
```javascript
// eval:
(async () => {
  Promise.reject(new Error('forgotten rejection'));
  return 'completed';
})()

// result shows completion + the unhandled rejection
```

### Multiple Concurrent Errors

When multiple errors occur during long-running operations:
```javascript
// eval:
(async () => {
  for (let i = 0; i < 3; i++) {
    setTimeout(() => { throw new Error(`error ${i}`); }, i * 50);
  }
  await new Promise(r => setTimeout(r, 200));
  return 'done';
})()

// result shows all three errors separated by ---
```

## Benefits for LLM Agents

1. **Complete visibility**: No errors are lost; everything that happens during eval is captured
2. **Context preservation**: Error stacks provide file/line information for debugging
3. **Pattern detection**: Repeated errors or error sequences can be analyzed programmatically
4. **Autonomous debugging**: An LLM can see both the intended result and any side-effect issues
5. **Better string representations**: Functions and undefined values now have meaningful string forms

## Backward Compatibility

- Evals that don't trigger errors will see no comment blocks (zero overhead)
- The core result format (JSON for success, stack for failure) remains unchanged
- Existing scripts using the REPL continue to work without modification

## Related Documents

- `docs/7-http-test-harness.md` - HTTP REPL specification
- `docs/7.1-file-test-harness.md` - File-based REPL specification
