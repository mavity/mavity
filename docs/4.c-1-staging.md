# Staging of Plan C

[See Quadrupoles / MAC](4.c-0-quadrupoles-mac.md) and [Plans and alternatives](4-refactoring-options.md) for context.

Absolutely—let’s design **debug “unloaders”** so each stage can be run **in isolation**, with **upstream mocked sources** and **downstream sinks**. Below is a high‑level plan with **function signatures and pseudocode only**, wired to your existing files and pipeline concepts. I’ll assume **`EXT_float_blend` is present** and lean on your current shader passes and state helpers. 

---

## 0) Concept: “Unloaders” = Source Mocks + Sinks + Routers

* **Source mocks** (“injectors”): produce **synthetic textures** that look exactly like the outputs of the upstream stage (e.g., level A0/A1/A2, or a force texture) so the stage under test can run **without** the real upstream.
* **Sinks** (“captures/validators”): consume outputs and **inspect/compare/log** without handing off to the real downstream.
* **Routers**: switch a pipeline call from **real** → **mock**, or from **stage output** → **sink**.

---

## 1) Top‑level debug control

**Add to `ParticleSystem` (host‑side controller).** 

```ts
type DebugMode =
  | 'FullPipeline'
  | 'AggregateOnly'        // aggregate L0 only, capture A0/A1/A2
  | 'ReduceOnly'           // run pyramid over provided L0, capture all levels
  | 'TraverseOnly'         // run force eval over provided levels, capture force
  | 'IntegrateOnly'        // run K/D/K over provided force
  | 'Record'               // record real outputs for replay
  | 'Replay'               // feed recorded outputs as mocks
  ;

interface DebugFlags {
  freezePositions?: boolean;           // pin positions across frames
  freezeVelocities?: boolean;          // pin velocities across frames
  useKDK?: boolean;                    // toggle symplectic scheduler
  momentumClamp?: boolean;             // subtract mean force/velocity
  visualizeLevel?: { level: number, attachment: 'A0'|'A1'|'A2' };
  diffAgainstGolden?: boolean;         // compare to saved “golden” textures
  breakAfterStage?: 'Aggregate'|'Reduce'|'Traverse'|'Integrate'|null;
}

class ParticleSystem {
  setDebugMode(mode: DebugMode): void
  setDebugFlags(flags: DebugFlags): void
  step_Debug(): void                  // orchestrates per-mode execution
}
```

**Router logic (pseudocode)**

```ts
function step_Debug():
  switch (debugMode):
    case 'AggregateOnly':
      DebugRouter.runAggregationHarness(this); break
    case 'ReduceOnly':
      DebugRouter.runReductionHarness(this); break
    case 'TraverseOnly':
      DebugRouter.runTraversalHarness(this); break
    case 'IntegrateOnly':
      DebugRouter.runIntegratorHarness(this); break
    case 'Record':
      DebugRouter.runFullPipeline_Record(this); break
    case 'Replay':
      DebugRouter.runFullPipeline_Replay(this); break
    default:
      this.step() // existing production path
```

(Uses your existing `step()` as the reference pipeline. )

---

## 2) Data contracts (so mocks match real outputs)

### 2.1 Particle textures (existing)

* **Positions**: RGBA32F, `xyz=world pos`, `a=mass` (as used in `aggregation.vert.js` and integration).  
* **Velocity**: RGBA32F, `xyz=vel`. 
* **Force**: RGBA32F, `xyz=accel`, `w=unused`. (Produced by traversal; consumed by velocity integrate.)  

### 2.2 Level textures per level Lk (extended Plan C)

* **A0** (existing): `RGBA32F = [Σ(m·x), Σ(m·y), Σ(m·z), Σm]`. Built in `aggregation.*` and `reduction.frag.js`.   
* **A1** (new): `RGBA32F = [Σ(m·x²), Σ(m·y²), Σ(m·z²), Σ(m·xy)]`.
* **A2** (new): `RGBA32F = [Σ(m·xz), Σ(m·yz), 0, 0]`.

(These contracts let traversal build COM and quadrupole locally. )

---

## 3) Source mocks (“unloaders” that *inject* data)

### 3.1 Synthetic particle sources

```ts
namespace DebugSource {
  function injectConstantForceField(system, vec3 F): void
  function injectAnalyticGravity(system, center: vec3, mass: number): void
  function injectGaussianBlobPositions(system, mean: vec3, sigma: vec3): void
  function injectTwoBody(system, p1, p2, v1, v2, m1, m2): void
}
```

* Writes directly into `positionTextures/velocityTextures` (staging FBOs) to **bypass aggregation/traversal**, for **IntegrateOnly** testing. Uses the same upload paths you already have. 

### 3.2 Synthetic level (A0/A1/A2) sources

```ts
namespace DebugSource {
  function makeEmptyLevels(system): LevelSet
  function paintDeltaMass(levelSet, level: number, voxel: ivec3, mass: float, pos: vec3): void
  function paintUniformDensity(levelSet, level: number, rho: float): void
  function paintShell(levelSet, level: number, center: vec3, radius: float, mass: float): void
}
```

* Produces **A0/A1/A2** for **all levels** consistent with your pyramid layout (including `gridSize` and `slicesPerRow` mapping used in `aggregation.vert.js`). 

### 3.3 Recorded sources (replay)

```ts
namespace DebugRecord {
  function startRecording(system, what: 'Levels'|'Force'|'Positions'|'All'): void
  function stopRecording(system): DebugCaptureBundle
  function startReplay(bundle: DebugCaptureBundle): void
}
```

* Wraps FBO blits so actual pass outputs are **copied** to a ring buffer of textures immediately after each stage. Later, **Replay** mode binds those textures instead of running the stage. (Pairs with your existing profiler labels and FBO routing.) 

---

## 4) Sinks (captures/validators/visualizers)

### 4.1 Captures (GPU→CPU or GPU→GPU diff)

```ts
namespace DebugSink {
  function captureTextureToCPU(glTex: WebGLTexture, w: int, h: int): Float32Array
  function captureLevelSetMetadata(levelSet): DebugJSON
  function captureMomentTotals(levelSet): { totalMass, globalCOM }
}
```

* Uses a minimal chain of downsample reductions (reuse `reduction.frag.js`) to sum **mass** and **mass‑weighted positions** to **1×1**, then read back once. 

### 4.2 Validators

```ts
namespace DebugValidate {
  function assertMassConservation(beforeLevels, afterLevels, eps): void
  function assertNoNaNs(glTex): void
  function assertMomentumReasonable(pos, vel, eps): void
  function compareTexturesRMSE(texA, texB, outDiffTex?, threshold): {rmse, maxAbs}
}
```

* `compareTexturesRMSE` runs a GPU RMSE pass (fullscreen shader), writing optional `outDiffTex` for heatmap.

### 4.3 Visualizers (on‑screen)

```ts
namespace DebugViz {
  function blitLevelAttachment(levelSet, level, attachment: 'A0'|'A1'|'A2', toFBO, normalizeMode): void
  function overlayCOMMarkers(levelSet, level, toFBO): void
  function showForceField(forceTex, toFBO, arrowScale): void
}
```

* Uses your `fullscreen.vert` and a tiny fragment to decode `A0/A1/A2` into colors; draws to a side‑by‑side debug FBO. 

---

## 5) Per‑stage harnesses (run a single stage *unplugged*)

### 5.1 Aggregation harness

```ts
namespace DebugRouter {
  function runAggregationHarness(system): void
}
```

**Pseudocode**

```
bind L0 FBO with MRT (A0,A1,A2)
clear to zero
bind positions = system.positionTextures.getCurrentTexture()
draw particles via programs.aggregation_MRT           // extend to write A1/A2
DebugSink.capture/certify level-0 totals
if (flags.breakAfterStage=='Aggregate') return
```

(Extends your existing aggregation call path.  )

### 5.2 Reduction harness

```ts
namespace DebugRouter {
  function runReductionHarness(system): void
}
```

**Pseudocode**

```
if (!has L0) DebugSource.paint...()                 // inject synthetic L0
for level=0..numLevels-2: pyramidReduce_MRT(level)  // sum A0,A1,A2 together
DebugSink.capture/certify root totals (1×1)
if (flags.breakAfterStage=='Reduce') return
```

(Reuses `reduction.frag.js` program and your loop; switch to MRT variant.)  

### 5.3 Traversal harness

```ts
namespace DebugRouter {
  function runTraversalHarness(system): void
}
```

**Pseudocode**

```
if (!levelsReady) DebugSource.paint...()            // inject full LevelSet
bind traversal program (programs.traversal)         // updated MAC + quad
bind A0/A1/A2 samplers per level
bind particle positions
draw fullscreen quad sized to particle texture       // one fragment per particle
DebugSink.capture force texture (optional RMSE vs golden)
if (flags.breakAfterStage=='Traverse') return
```

(Uses your existing traversal pass structure that writes force to a texture. )

### 5.4 Integrator harness (including KDK)

```ts
namespace DebugRouter {
  function runIntegratorHarness(system): void
}
```

**Pseudocode**

```
if (!forceTexReady) DebugSource.injectConstantForceField(system, F)
if (flags.useKDK) {
  kick(dt/2, forcePrev)      // vel_integrate.frag
  drift(dt)                  // pos_integrate.frag
  kick(dt/2, forceCurr)
} else {
  // existing production order
  pipelineIntegratePhysics(system)
}
if (flags.momentumClamp) DebugOps.applyCOMClamp(system)
DebugSink.capture positions/velocities
```

(Reuses your `vel_integrate.frag.js` and `pos_integrate.frag.js` passes and their uniforms.)  

---

## 6) Replay/Record (isolation without mocks you hand‑write)

```ts
namespace DebugRecord {
  function wrapStageOutput(stage: 'Aggregate'|'Reduce'|'Traverse'|'Integrate', texOrLevels): void
  function bindReplayForStage(stage, texOrLevels): void
}
```

**Usage examples**

```
runFullPipeline_Record:
  after Aggregate: wrapStageOutput('Aggregate', L0)
  after Reduce:    wrapStageOutput('Reduce',   LevelsAll)
  after Traverse:  wrapStageOutput('Traverse', forceTex)
runFullPipeline_Replay:
  before Reduce:   bindReplayForStage('Aggregate', L0_saved)
  before Traverse: bindReplayForStage('Reduce',   LevelsAll_saved)
  before Integrate:bindReplayForStage('Traverse', forceTex_saved)
```

(Piggybacks your FBO routing inside `ParticleSystem` to copy textures.) 

---

## 7) Determinism & invariants (fast checks you can run every frame)

```ts
namespace DebugOps {
  function computeMassAndCOM(levels): {M, COM}
  function computeLinearMomentum(posTex, velTex): vec3
  function applyCOMClamp(system): void              // subtract mean vel or mean force
  function forwardReverseTest(system, steps: int): float // average position delta
}
```

* `computeMassAndCOM` uses the existing reduction to 1×1.
* `forwardReverseTest` orchestrates KDK forward N, flip velocities, back N; returns RMS error. (Controlled entirely by the host scheduler.) 

---

## 8) Wiring into your existing GL helpers and profiler

* **Unbinds & FBO checks**: call `unbindAllTextures()`, `checkFBO(tag)`, `checkGl(tag)` **before/after** each harness stage. (You already expose these in `ParticleSystem`.) 
* **Timers**: wrap each harness pass with `profiler.begin/end('stage')` so perf is visible even when running in isolation. (You already have a `GPUProfiler` instance.) 

---

## 9) Minimal public API you’d add (signatures only)

```ts
// ParticleSystem (host)
setDebugMode(mode: DebugMode): void
setDebugFlags(flags: DebugFlags): void
step_Debug(): void

// Debug router & harnesses
namespace DebugRouter {
  runAggregationHarness(ps: ParticleSystem): void
  runReductionHarness(ps: ParticleSystem): void
  runTraversalHarness(ps: ParticleSystem): void
  runIntegratorHarness(ps: ParticleSystem): void
  runFullPipeline_Record(ps: ParticleSystem): void
  runFullPipeline_Replay(ps: ParticleSystem): void
}

// Sources / Sinks / Validators / Viz
namespace DebugSource { /* as defined above */ }
namespace DebugSink   { /* as defined above */ }
namespace DebugValidate { /* as defined above */ }
namespace DebugViz    { /* as defined above */ }
namespace DebugRecord { /* as defined above */ }
namespace DebugOps    { /* as defined above */ }
```

---

## 10) How this isolates each existing file/stage

* **`aggregation.vert.js` / `aggregation.frag.js`**: run independently under **AggregateOnly**; MRT outputs A0/A1/A2; **no dependency** on traversal/integration.  
* **`reduction.frag.js`**: run independently under **ReduceOnly** over synthetic L0; validates 8‑child sum and 3‑attachment carry. 
* **`traversal.frag.js`**: run independently under **TraverseOnly** on injected **LevelSet**; compares force vs. golden or analytic fields. 
* **`vel_integrate.frag.js` / `pos_integrate.frag.js`**: run under **IntegrateOnly** with injected constant/analytic forces (or recorded force), including **KDK** ordering.  
* **`fullscreen.vert.js`**: used by all sinks/visualizers that blit or compute RMSE. 
* **`particle-system.js`**: holds the **routers**, **debug orchestration**, and **toggle state**; keeps the production `step()` intact for easy A/B. 

## 11) Preparatory wiring (Plan C toggle)

- **UI toggle** Add a `Plan C` checkbox in the main demo UI next to the profiling control. Default unchecked.
- **Particle system flag** Extend `particle-system/index.js` to accept a `planC` boolean (default `false`). Pass it through to `ParticleSystem` options so shaders/pipelines can branch cleanly.
- **Toggle behavior** When the checkbox flips, dispose and reinstantiate the particle system with the new `planC` value to avoid mixed-state GPU resources.
- **DevTools hook** Attach `window.planC = (enabled) => { setToggle(enabled); applyPlanC(enabled); }` so engineers can flip modes from the console.
- **Staging usage** Once the flag exists, guard all PM/FFT staging code behind `if (psys.options.planC)` checks. With the toggle on, follow the stage-isolated workflow above using the embedded browser for debugging.


---

### TL;DR

Yes—by adding **source mocks**, **sinks**, and **routers**, you can run **each stage in isolation**: aggregate, reduce, traverse, or integrate—without the rest of the pipeline. The plan above gives you the **function signatures**, **pseudocode**, **data contracts**, and the wiring points in your current files to make this practical while you implement Plan C.
