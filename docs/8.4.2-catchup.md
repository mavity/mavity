# `GravityMesh` Modernization Plan

This document outlines the plan to modernize `GravityMesh` by adopting advanced patterns from `GravitySpectral`, focusing on GPU-side optimizations, resource management, and API consistency.

## 1. Dynamic World Bounds with `KBoundsReduce`

`GravityMesh` will be updated to dynamically calculate the simulation's world bounds on the GPU, eliminating the need for static, pre-configured bounds and improving accuracy for evolving particle systems.

-   **Integration**: A `KBoundsReduce` kernel will be added to the `GravityMesh` constructor.
-   **Execution Cycle**:
    -   Every `boundsInterval` frames (e.g., 30), the `KBoundsReduce` kernel will run on the `positionMassTexture`.
    -   The resulting 2x1 bounds texture (min/max) will be read back to the CPU using a pre-allocated framebuffer and buffer to avoid per-frame allocations.
-   **State Propagation**:
    -   The new bounds, expanded with a small margin to prevent thrashing, will update `this.worldBounds`.
    -   A new `massToDensity` scaling factor will be computed from the updated `worldVolume`.
    -   This new scaling information will be propagated to all relevant kernels on each update:
        -   `depositKernel.worldBounds`
        -   `fftKernel.massToDensity` (or equivalent `cellVolume`)
        -   `poissonKernel.worldSize`
        -   `gradientKernel.worldSize`
        -   `forceSampleKernel.worldBounds`
        -   `nearFieldKernel.worldBounds`

## 2. KFFT Unification and Modernization

To enhance efficiency, reduce code duplication, and align with best practices, `GravityMesh` will stop using its local `k-fft.js` and directly reuse the advanced kernel from `gravity/spectral/k-fft.js`. This involves the following changes:

-   **Direct Reuse of `spectral/k-fft.js`**: The local `gravity/mesh/k-fft.js` will be deleted. `GravityMesh` will be updated to import `../spectral/k-fft.js`.

-   **Single `KFFT` Instance**: The separate `fftForwardKernel` and `fftInverseKernel` instances will be replaced by a single, more efficient `fftKernel`. The transform direction will be controlled by setting `fftKernel.inverse = true/false` before each run.

-   **API and Texture Packing Alignment**:
    -   The `KFFT` instantiation will be updated to use `massToDensity` instead of `cellVolume`.
    -   All 3D grid textures will adopt non-square packing. Explicit `textureWidth` and `textureHeight` will be passed to all kernels instead of a single `textureSize`.

-   **Lean Texture Management**:
    -   The number of dedicated FFT-related textures will be reduced. The single `KFFT` instance will manage its internal `complexFrom` and `complexTo` textures.
    -   Scratch textures will be reused where possible. For instance, during inverse FFTs, the `inPotentialSpectrum` texture from the `gradientKernel` can be borrowed as a scratch buffer.

-   **Texture Ownership Protocol**: A strict texture ownership and borrowing protocol, as seen in `GravitySpectral`, will be implemented to manage the lifecycle of complex textures between the FFT, Poisson, and Gradient kernels. This ensures no race conditions and minimizes texture bindings.

## References to Project conventions

[WebL2 Kernels](8-webgl-kernels.md) describes the key conventions especially to do with initialisation and triad-typed parameters. Note that this is already implemented in [GravitySpectral](../gravity/spectral/gravity-spectral.js) and GravityMesh must follow the example and the spirit.

[Reflection](10-reflection.md) describes the debugging features in valueOf and toString that must be exposed in kernels and whole gravity system too.Adjust Mesh's kernels and GravityMesh to follow (no need to change shared kernels).

## Followups

- Deprecate legacy mesh kernels `gravity/mesh/k-poisson.js` and `gravity/mesh/k-force-sample.js`; either remove them once fully unused or add clear deprecation headers noting that `GravityMesh` reuses spectral kernels.
- Add `GravityMesh.valueOf()` and `GravityMesh.toString()` as per Reflection (docs/10-reflection.md): include worldBounds/worldSize, gridSize/slicesPerRow, packed grid texture dims, massToDensity/cellVolume, render counts, and key texture identifiers to support Daebug interrogation.
- Document the texture ownership/borrowing protocol in `gravity-mesh.js` near `_computeMeshForces()` to clarify lifetimes and hand-offs between FFT/Poisson/Gradient and scratch reuse.

## Progress Log

- Added GPU bounds reduction to `GravityMesh` using `KBoundsReduce` with periodic readback and world bounds update; propagated updated mass scaling and world sizes to FFT/Poisson/Gradient/Deposit/ForceSample/NearField.
- Switched `GravityMesh` to reuse `../spectral/k-fft.js` as a single `KFFT` instance; refactored `_computeMeshForces()` to the spectral texture-ownership protocol and inverse-FFT sequence writing to `forceGridX/Y/Z`.
- Kept existing square texture packing and preallocated complex textures as safe fallbacks; avoided any file deletions per guidance.
- Fixed parameter names and types when using `KBoundsReduce` in `gravity/spectral/gravity-spectral.js` and resolved `@ts-check` issues (removed implicit `any` and ensured textures are non-null when passed to FFT).
- Updated Mesh `KGradient` to use spectral gradient shader and accept `textureWidth`/`textureHeight`; viewport and uniforms now use packed 3D dims.
- Switched `GravityMesh` Poisson to reuse `../spectral/k-poisson.js` with option mapping: pass `gravitationalConstant = 4πG`, uppercase `assignment` for deconvolution order, set `poissonUseDiscrete = true`, map `treePMSigma = splitSigma`, configure `splitMode` and forward `kCut`; used a minimal type cast to pass `kCut` pending JSDoc alignment.
- Switched `GravityMesh` force sampling to reuse `../spectral/k-force-sample.js` for both far-field and near-field accumulation; pass `textureWidth/textureHeight` consistently.
- Extended Mesh `KDeposit` and `KNearField` to accept `textureWidth`/`textureHeight`; updated their viewports, texture allocation, readbacks, and uniforms to use packed 3D dimensions.
- Flipped `GravityMesh` to true non-square packed 3D textures end-to-end: compute `sliceRows = ceil(gridSize / slicesPerRow)`, set `gridTextureWidth = gridSize * slicesPerRow`, `gridTextureHeight = gridSize * sliceRows`; allocate mass grid, complex spectra, force spectra, and force grids with non-square dimensions; pass `textureWidth/textureHeight` to `KDeposit`, `KFFT`, `KPoisson`, `KGradient`, `KForceSample` (far and near), and `KNearField`.

## Notable technical decisions

- Reuse the spectral `KFFT` implementation in Mesh to reduce duplication and align behavior; keep `gravity/mesh/k-fft.js` untouched for now (no deletions until the end).
- Non-square packed textures are now enabled in Mesh; all mesh kernels accept and use `textureWidth`/`textureHeight`.
- Derive `massToDensity` as `1 / cellVolume` on bounds updates to keep spectral FFT scaling correct.
- Migrate Mesh kernels to non-square-ready APIs first (pass width/height everywhere), then flip actual packing across Mesh once all kernels are aligned.
- Reuse the spectral `KPoisson` in Mesh; map options explicitly:
    - `gravitationalConstant = 4πG` (Mesh’s `gravityStrength` → spectral constant)
    - `assignment` uppercased to drive deconvolution order (NGP=1, CIC=2, TSC=3)
    - `poissonUseDiscrete = true` to match Mesh’s discrete kernel
    - Gaussian split: `treePMSigma = splitSigma`; hard cutoff: `splitMode = 1` with `kCut`
    - Forward `textureWidth`/`textureHeight` (non-square enabled)
    - Note: `kCut` is supported by the implementation but not in JSDoc; tolerate via a local cast until docs are updated

 