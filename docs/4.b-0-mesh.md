# Plan B (PM/FFT/TreePM)

The plan reuses your current pipeline, leverages your **sliced 3D‑in‑2D grid** mapping, and assumes **`EXT_float_blend` is present** (so we freely use additive blending to float render targets). Where I refer to files you already have, I cite them inline so you can see exactly what to reuse or lightly adapt.

---

## 0) Scope & defaults

- **Domain & BCs:** Use **periodic boundaries** on a **fixed box** `[worldMin, worldMax]`. Freeze `worldBounds` during PM mode (don’t auto‑shrink/grow the box), because the FFT assumes a stationary, periodic domain. (Your `ParticleSystem` currently refreshes bounds every ~10 s; disable or noop that in PM mode.)
- **Grid:** Reuse your **L0 grid** parameters as the PM grid: `gridSize = octreeGridSize` (e.g., 64) and `slicesPerRow = octreeSlicesPerRow` (e.g., 8) → **L0 texture of (gridSize \* slicesPerRow)²** (e.g., 512×512). You already compute exactly these dimensions.
- **Split:** Far‑field via **PM** (FFT Poisson solve), short‑range via **local real‑space correction** over a small neighborhood of L0 cells (a trimmed version of what your `traversal.frag.js` already does).
- **Assignment:** Start with **NGP** (nearest‑grid‑point) mass deposition (already what your L0 aggregation effectively does), then optionally upgrade to **CIC** later.
- **No fallbacks:** Assume `EXT_color_buffer_float` and `EXT_float_blend` are present; we use **additive blending to float targets**. Your capability checks already exist.

---

## 1) New pipeline at a glance

Replace `buildQuadtree → traversal (BH)` with **PM/FFT** passes + **near‑field** correction:

```
step():
  if (!initialized) return
  // 1) PM: deposit mass to grid
  buildPMGrid()             // L0 only; no pyramid
  // 2) FFT: ρ(x) -> ρ̂(k)
  fftForward3D()
  // 3) K-space Poisson + (optional) split/filter/deconvolution
  solvePoissonInK()
  // 4) Acceleration in k-space and inverse FFT to a_x,a_y,a_z on grid
  computeAccelerationK()
  fftInverse3DToAcceleration()
  // 5) Sample PM acceleration at particles (trilinear interpolation)
  samplePMAccelerationAtParticles()
  // 6) Short-range correction in real space (local L0 neighborhood)
  computeNearFieldCorrection()
  // 7) Integrate (reuse existing)
  integratePhysics()
```

- Integrator stays the same for now (`vel_integrate.frag.js` then `pos_integrate.frag.js`), though you can later re‑order to KDK leapfrog.

---

## 2) New resources (textures/programs)

**Textures (sliced 3D in 2D, same layout as L0):**

- `rhoReal` : real mass density (R32F or RG32F if you decide to pack) @ size `(gridSize*slicesPerRow)²`.
- `rhoK` : complex ρ̂(k) (RG32F: R=real, G=imag).
- `phiK` : complex φ̂(k) (RG32F).
- `gKx,gKy,gKz` : complex acceleration components in k‑space (RG32F each) or pack into RGBA32F×2.
- `accelX, accelY, accelZ` : real‑space acceleration fields (R32F each) after iFFT.
- (Reuse) `levelTextures[0]` as **L0** (mass and COM numerators) which your aggregation already fills; we will read **A channel (= mass)** from it to seed `rhoReal`.

**Programs (compile once in `createShaderPrograms`)**:

```
createProgramPM():
  programs.pmDeposit = createProgram(aggregationVert, pmDepositFrag)          // NGP (mass only)
  programs.fftX = createProgram(fullscreenVert, fft1DFrag)                    // param: dim='X'
  programs.fftY = createProgram(fullscreenVert, fft1DFrag)                    // param: dim='Y'
  programs.fftZ = createProgram(fullscreenVert, fft1DFrag)                    // param: dim='Z' (across slices)
  programs.poissonK = createProgram(fullscreenVert, poissonFrag)              // multiply by Green's fn + split filter + optional deconv
  programs.gradK   = createProgram(fullscreenVert, gradientKFrag)             // ĝ = i k φ̂
  programs.copyMassFromL0 = createProgram(fullscreenVert, copyMassFrag)       // L0.A → rhoReal
  programs.samplePM = createProgram(fullscreenVert, samplePMFrag)             // trilinear gather at particles
  programs.nearField = createProgram(fullscreenVert, nearFieldFrag)           // local L0 correction
```

- Reuse your existing `createProgram`, fullscreen quad, MRT setup, and FBO helpers.

---

## 3) Pass‑by‑pass specifications (signatures + pseudocode)

### 3.1 Mass deposition (L0 only; no pyramid)

**Signature**

```
function buildPMGrid(ps: ParticleSystem): void
```

**Pseudocode**

```
disable auto-bounds update for PM (fixed periodic box)
clear rhoReal to 0
// Option A (least change): reuse existing aggregation to L0, then copy mass channel
clear L0 (your existing code already clears all levels)
aggregateL0(ps)                               // writes (∑m·x, ∑m·y, ∑m·z, ∑m) into L0 with additive float blend
copyMassFromL0ToRho(ps)                       // sample L0.A and write to rhoReal
```

- You already have `aggregateParticlesIntoL0` paths and the 3D‑slice mapping in `aggregation.vert.js`. We’ll keep it.
- **Don’t run pyramid reduction** for PM (levels > 0 are not needed for far‑field). Your `buildQuadtree()` does the pyramid; create a sibling `buildPMGrid()` that runs only the L0 aggregation and the mass copy.

> **Optional later:** Replace NGP with **CIC**: in `aggregationVert`, compute fractional offsets to the 8 surrounding cells and write mass to all 8 via MRT or 8 draw calls; PM accuracy improves and you can later **deconvolve** the CIC window in k‑space.

---

### 3.2 3D FFT (forward & inverse)

We implement **Stockham 1D FFT** passes along **X**, then **Y**, then **Z** (Z runs **across slices** in your 2D layout). Each pass reads a source 2D texture and writes to a target 2D texture. You already have the fullscreen quad vertex shader.

**Signatures**

```
function fftForward3D(ps: ParticleSystem, src: Texture2D /*rhoReal*/, dst: Texture2D /*rhoK*/): void
function fftInverse3D(ps: ParticleSystem, src: Texture2D /*gK* component*/, dst: Texture2D /*accel component*/): void
```

**Pseudocode**

```
fftForward3D:
  tmp = complexizeReal(src)            // set imag=0
  tmp = fft1D(tmp, dim='X', forward=true)
  tmp = fft1D(tmp, dim='Y', forward=true)
  dst = fft1D(tmp, dim='Z', forward=true)

fftInverse3D:
  tmp = fft1D(src, dim='Z', forward=false)
  tmp = fft1D(tmp, dim='Y', forward=false)
  dst = fft1D(tmp, dim='X', forward=false)
  ifft normalization (1/NxNyNz) inside the last pass
```

**Notes**

- **Indexing:** Your 3D→2D slice mapping (used in aggregation/traversal) provides the needed conversions. Reuse the **voxel↔texel** helpers logic (ported to the FFT shaders).
- **Wavenumbers (k):** define

  ```
  kx = 2π * ((ix <= Nx/2) ? ix : ix - Nx) / Lx
  ```

  similarly for `ky,kz`, where `Lx = worldMax.x - worldMin.x`, etc.

---

### 3.3 K‑space Poisson solve (+ split + deconvolution)

**Signature**

```
function solvePoissonInK(ps: ParticleSystem, rhoK: Texture2D /*complex*/, outPhiK: Texture2D): void
```

**Mathematics**

- Discrete Poisson in Fourier domain (periodic):

  ```
  φ̂(k) = -4πG * ρ̂(k) / max(|k|^2, ε_k)        // set φ̂(0)=0
  ```

- **PM/Band split (TreePM)** — choose one:

  **S1. Hard spectral split (simple):**

  ```
  H(k) = 1 if |k| ≤ k_cut, else 0
  φ̂_LR(k) = H(k) * (-4πG ρ̂(k) / |k|^2)
  ```

  Near‑field will handle high‑k.

  **S2. Smooth Gaussian split (Ewald‑like):**

  ```
  H(k) = exp(-|k|^2 σ^2)         // σ ~ r_split
  φ̂_LR(k) = H(k) * (-4πG ρ̂(k) / |k|^2)
  ```

  Near‑field uses the complementary kernel (see §3.6).

- **Assignment deconvolution (optional, recommended for CIC):** If you deposit with CIC, multiply by `1 / W_CIC(k)` once on ρ̂(k) (or divide Green’s function by `W_CIC^2(k)` depending on convention).

**Pseudocode**

```
for each frequency sample (kx,ky,kz):
  if k == 0: outPhiK = 0
  else:
    H = chooseSplitFilter(k)           // S1 or S2
    denom = kx*kx + ky*ky + kz*kz
    phiK = (-4πG / denom) * rhoK
    outPhiK = H * phiK                 // complex multiply by scalar
```

---

### 3.4 Acceleration in k‑space, then inverse FFT to real

**Signature**

```
function computeAccelerationK(ps: ParticleSystem, phiK: Texture2D,
                              outGKx: Texture2D, outGKy: Texture2D, outGKz: Texture2D): void

function fftInverse3DToAcceleration(ps: ParticleSystem,
                                    gKx: Texture2D, gKy: Texture2D, gKz: Texture2D,
                                    outAx: Texture2D, outAy: Texture2D, outAz: Texture2D): void
```

**Pseudocode**

```
computeAccelerationK:
  // ĝ = -∇φ̂ = i * (kx,ky,kz) * φ̂
  gKx = complex( -i*kx ) * phiK
  gKy = complex( -i*ky ) * phiK
  gKz = complex( -i*kz ) * phiK

fftInverse3DToAcceleration:
  outAx = fftInverse3D(gKx)
  outAy = fftInverse3D(gKy)
  outAz = fftInverse3D(gKz)
```

---

### 3.5 Sample PM acceleration at particles (O(N))

**Signature**

```
function samplePMAccelerationAtParticles(ps: ParticleSystem,
                                         accelX: Texture2D, accelY: Texture2D, accelZ: Texture2D,
                                         outForce: Texture2D /* RGBA32F, xyz used */): void
```

**Pseudocode**

```
for each particle texel coord:
  p = fetch position from u_positions
  // normalized coords in [0,1)^3 using fixed world bounds
  norm = (p - worldMin) / (worldMax - worldMin)
  // trilinear interpolate from sliced 3D accel textures
  ax = trilinearSample(accelX, norm, gridSize, slicesPerRow)
  ay = trilinearSample(accelY, norm, gridSize, slicesPerRow)
  az = trilinearSample(accelZ, norm, gridSize, slicesPerRow)
  write (ax, ay, az, 0) to outForce
```

- Reuse your **voxel↔texel** mapping from `aggregation.vert.js` / `traversal.frag.js` (ported as inline functions for the sampler).

---

### 3.6 Short‑range correction (local real‑space)

**Signature**

```
function computeNearFieldCorrection(ps: ParticleSystem,
                                    L0: Texture2D /*levelTextures[0]*/,
                                    inOutForce: Texture2D): void
```

**Goal:** Add back the **high‑k** (short‑range) portion that PM filtered out.

**Two implementations (choose one):**

- **NF‑1 (hard split companion; simplest):**
  PM used **hard k‑cut** at `k_cut`. In real space, apply **Newtonian** force to neighbors within **r_cut ≈ π/k_cut**, and **0** beyond:

  ```
  F_SR(r) = F_Newton(r) for r < r_cut, else 0
  ```

  This is easy and pairs naturally with S1.

- **NF‑2 (Gaussian companion; smoother):**
  PM used **H(k)=exp(-|k|^2 σ^2)**. Then near‑field uses the **complementary Ewald term** in real space:

  ```
  φ_SR(r) = -G m * erfc( r / (2σ) ) / r
  F_SR(r) = -∇φ_SR(r)   // closed form involves erfc and exp terms
  ```

  Smooth and physically nice; slightly more math in the shader.

**Neighborhood and data:**

- Follow your current **L0 neighborhood loop** pattern (already in `traversal.frag.js`) to visit, e.g., a **5×5×5** or **3×3×3** block around the particle’s L0 voxel, read **(∑m·x,∑m·y,∑m·z,∑m)**, compute the neighbor cell’s **COM** and **mass**, and add `F_SR` for that lump. This gives a good approximation without per‑cell particle lists (works in WebGL2).

**Pseudocode**

```
for each particle:
  p = position
  find my L0 voxel (as in traversal.frag.js)
  total += Sum over neighbors:
              m = L0.A; if m == 0 continue
              com = L0.rgb / m
              r = com - p
              if NF-1:
                if |r| < r_cut: total += newton(m, r, softening)
              if NF-2:
                total += ewaldShortRange(m, r, sigma)
  inOutForce += total
```

---

### 3.7 Integrate (reuse)

**Signature**

```
function integratePhysics(ps: ParticleSystem): void
```

- Reuse your existing velocity and position integration passes, which write ping‑pong velocity/position textures and cap speed/accel if desired. (Later, switch to **KDK leapfrog** by ordering vel/pos passes accordingly.)

---

## 4) ParticleSystem wire‑up (new entry points)

**Signatures (host side orchestration)**

```
function createPMResources(ps: ParticleSystem): void
function createPMPrograms(ps: ParticleSystem): void
function pipelineCalculateForcesPM(ps: ParticleSystem): void

// Step loop variant
function stepPM(ps: ParticleSystem): void
```

**Pseudocode**

```
createPMResources:
  allocate rhoReal, rhoK, phiK, gKx,gKy,gKz, accelX,accelY,accelZ with sizes derived from ps.L0Size

createPMPrograms:
  compile programs listed in §2 using ps.createProgram(...)

pipelineCalculateForcesPM:
  buildPMGrid(ps)                              // L0 aggregation + copyMassFromL0
  fftForward3D(ps, rhoReal, rhoK)
  solvePoissonInK(ps, rhoK, phiK)
  computeAccelerationK(ps, phiK, gKx,gKy,gKz)
  fftInverse3DToAcceleration(ps, gKx,gKy,gKz, accelX,accelY,accelZ)
  clearForceTexture(ps)                        // you already have this
  samplePMAccelerationAtParticles(ps, accelX,accelY,accelZ, forceTexture)
  computeNearFieldCorrection(ps, L0, forceTexture)

stepPM:
  if (ps.profiler) profiler.update()
  // disable bounds auto-update in PM (fixed periodic domain)
  pipelineCalculateForcesPM(ps)
  pipelineIntegratePhysics(ps)                 // reuse
  ps.frameCount++
```

- You already have `createShaderPrograms`, texture/FBO helpers, fullscreen quad VAO, and **per‑pass profiling**; mirror that style for the new passes.

---

## 5) Definitions you’ll need in shaders

**5.1 Coordinate transforms**

```
norm = (pos - worldMin) / (worldMax - worldMin)              // wrap to [0,1) for periodic
voxel = floor(norm * gridSize)                               // 3D integer
sliceIndex = voxel.z
sliceRow = floor(sliceIndex / slicesPerRow)
sliceCol = sliceIndex - sliceRow * slicesPerRow
texel = (sliceCol * gridSize + voxel.x, sliceRow * gridSize + voxel.y)
```

— This matches your current aggregation & traversal mapping.

**5.2 Wavenumber indexing**

```
kx = 2π * ((ix <= Nx/2) ? ix : ix - Nx) / Lx   // similarly ky,kz
k2 = kx*kx + ky*ky + kz*kz
```

**5.3 FFT normalization**

- Use **unitary inverse** (apply `1/(NxNyNz)` in last iFFT pass) or split √N per pass; just be consistent.

**5.4 Deconvolution (optional if CIC)**

```
W_CIC(k) = Π_d [ sinc(π k_d Δx / 2) ]^2
rhoK_corrected = rhoK / W_CIC(k)
```

**5.5 Poisson + split (choose one)**

- **S1 (hard):** `H(k)=1[|k| ≤ k_cut]`, `r_cut ≈ π/k_cut`
- **S2 (Gaussian):** `H(k)=exp(-|k|^2 σ^2)`, `r_split ≈ σ`
  For NF‑2 use the Ewald short‑range **erfc** expression.

**5.6 Softening**

- Keep your existing softening in the **near‑field** term only (the PM field is smooth). Your traversal/near‑field code already uses softened Newtonian force.

---

## 6) What to **reuse**, **modify**, **remove**

- **Reuse as‑is:**

  - Fullscreen quad vertex (`fullscreen.vert.js`).
  - Position/velocity integrators (`pos_integrate.frag.js`, `vel_integrate.frag.js`).
  - L0 aggregation vertex shader (`aggregation.vert.js`) and the idea of sliced 3D → 2D.

- **Modify/add:**

  - Add `copyMassFromL0ToRho` pass (simple single‑channel copy from `L0.A`).
  - Add PM/FFT shader programs (fft1D, poisson, gradientK, samplePM, nearField).
  - In `ParticleSystem`, add **PM resources/programs** and a **PM step path** (e.g., `stepPM`).

- **Skip/remove during PM mode:**

  - The **pyramid reduction** levels `L1..L6` for far‑field (keep L0 for near‑field). Your current `buildQuadtree()` always reduces—PM path should **not** call it.

---

## 7) Parameters & tuning (starting points)

- `gridSize`: 64 (as you have) → upgrade to 128 if mobile memory allows.
- **Split (S1):** `k_cut = π / r_cut` with `r_cut = 2–3` grid cells.
- **Split (S2):** `σ = r_split ≈ 1.0–1.5` grid cells.
- **Near‑field neighborhood:** start with **3×3×3** L0 cells (or **5×5×5** if you keep it fast). Use your existing neighbor loop pattern from `traversal.frag.js`.
- **Softening (near‑field only):** match your current.
- **Integrator dt:** keep; consider switching to **KDK leapfrog** later for better long‑term energy behavior (reorder your two integration passes accordingly).

---

## 8) Validation checklist

- **Momentum test:** total momentum stays ~constant (PM + symmetric near‑field should have minimal drift).
- **Forward–reverse test:** integrate T forward, negate velocities, integrate T back → small residual (improves further with KDK).
- **Spectral sanity:** turn off near‑field; confirm far‑field alone gives smooth, large‑scale flows; then add near‑field and check small‑scale structure restores without “murmurations.”
- **θ‑free:** there’s no BH θ now; tune `k_cut`/`σ` + near‑field radius instead.

---

### Quick mapping to your files

- **`ParticleSystem`**: add PM resources/programs and a `stepPM()` path; don’t call `buildQuadtree()` in PM mode; keep `clearForceTexture()` and existing integrate/render.
- **`aggregation.vert.js`**: reuse its 3D→2D slice mapping to L0 for mass deposition (NGP).
- **`aggregation.frag.js`**: currently passes `v_particleData` through; for PM, add a new fragment that writes **mass only** to `rhoReal` (or just copy `L0.A` via a dedicated pass).
- **`reduction.frag.js`**: not used by PM far‑field; keep available for other modes.
- **`traversal.frag.js`**: retire BH traversal; keep its **L0 neighbor logic** snippet as the basis of the **near‑field** pass.
- **`vel_integrate.frag.js` / `pos_integrate.frag.js`**: reuse unchanged.
- **`fullscreen.vert.js`**: reuse for FFT and other fullscreen passes.
