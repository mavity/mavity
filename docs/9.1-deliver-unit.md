# Technical Blueprint: WebGL2 Unit Test Framework (Single-Worker Architecture)

This document provides a detailed, prescriptive implementation plan for the WebGL2 unit testing framework. It translates the high-level architecture into a set of concrete tasks and message specifications, serving as a direct guide for development. This revision adopts a **single-worker architecture** to prioritize implementation simplicity while maintaining a responsive, real-time testing environment with robust timeout protection.

Important constraint: this project must not introduce extra runtime dependencies. Do NOT use third-party packages such as `chokidar` or `chai`. The implementation should rely only on Node.js built-ins (for example `fs.watch` for file watching) and a tiny, local implementation of an `assert` helper that mirrors a minimal subset of Node's built-in assertion API. This keeps the test harness lightweight and avoids pulling in large dependency trees.

## 1. Component Implementation Plan

### 1.1. The Orchestrator (`serve.js`)

(No changes to this section. The Orchestrator's role remains the same.)

*   **Task 1.1.1: Test File Discovery and Watching**
    *   On startup, the server must recursively scan the project directory to find all files matching the `*.test.js` pattern.
    *   It will establish a file watcher using the Node.js built-in `fs.watch` API on each of these files. Do NOT introduce `chokidar` or other file-watching libraries; rely on `fs.watch` and a robust debounce to mitigate platform quirks.
    *   A debounce mechanism (e.g., 250ms) must be implemented to batch file-change events into a single test run trigger. The debounce should wait for a short quiet period before initiating a run.

*   **Task 1.1.2: Special Endpoint Routing**
    *   The main HTTP request handler must be updated to route `GET /test` and `GET /worker.js`.

*   **Task 1.1.3: `GET /test` - Supervisor Page Generation**
    *   This endpoint will generate a dynamic HTML5 document containing a `<pre id="results"></pre>` element and a `<script type="importmap">` block with mappings for `three`.
    *   The server will inject the Supervisor script (detailed in 1.2) into the response.

*   **Task 1.1.4: `GET /worker.js` - Worker Genesis Script Generation**
    *   This endpoint will serve the JavaScript payload for the Execution Cell (detailed in 1.3).

*   **Task 1.1.5: Test Run Command & Reporting**
    *   When a test run is triggered, the Orchestrator will respond to the Supervisor's long-polling `GET` request.
    *   The response will have a `Content-Type` of `application/json` and its body will be the `CMD_RUN_TESTS` data message (see Message Flow 2.1).
    *   It will await the final `REPORT_RUN_COMPLETED` message from the Supervisor, format it, and print the summary to the console.

### 1.2. The Supervisor (Injected Script on `/test` Page)

The Supervisor manages the worker and enforces a strict execution timeout.

*   **Task 1.2.1: Initialization & REPL Handshake**
    *   The injected script must be modified to handle both JavaScript (`eval`) and JSON (data message) responses from the REPL long-poll.
    *   It will connect to the REPL with the name `unit-test-supervisor` and expose a global `window.testRunner` object with a `handleCommand(command)` method.

*   **Task 1.2.2: Worker Supervision and Timeout Enforcement**
    *   The `handleCommand` function will be called when a `CMD_RUN_TESTS` message is received.
    *   It will define a `watchdogTimeout` (e.g., 10 seconds) to guard against a silent or frozen worker.
    *   It will then:
        1.  If a previous worker is still active, terminate it.
        2.  Clear the UI and reset its internal state.
        3.  Create **one** new worker: `new Worker('/worker.js', { type: 'module' })`.
        4.  Start the watchdog timer. If this timer ever fires, the Supervisor **must** call `worker.terminate()` on the worker, mark the entire run as a timeout failure, and send the final report to the Orchestrator.
        5.  Dispatch the `TASK_EXECUTE_RUN` message to the worker (see Message Flow 2.2).

*   **Task 1.2.3: Real-time Progress Display and Final Reporting**
    *   An `onmessage` handler on the worker will listen for the unified `EVENT_RUN_STATE_UPDATE` message.
    *   Upon receiving any message from the worker, the Supervisor **must reset the watchdog timer**, confirming the worker is still active.
    *   It will then re-render the UI with the latest results from the message payload.
    *   If the number of results in the payload equals the total number of tests dispatched, the Supervisor considers the run complete and sends the final `REPORT_RUN_COMPLETED` message to the Orchestrator.

### 1.3. The Execution Cell (`/worker.js` Script)

The single worker is a sequential test runner that provides periodic state updates.

*   **Task 1.3.1: Awaiting the Task**
    *   The script will listen for the single `TASK_EXECUTE_RUN` message from the Supervisor.

*   **Task 1.3.2: Test Harness and Debounce Implementation**
        *   The script must define and expose a global `test(name, fn)` function and a global `assert` object.
        *   The `assert` object must be a tiny, local implementation that mirrors the behavior and API shape of Node's built-in `assert` for the minimal methods used by the test-suite. Implement at least:
                - `assert.ok(value, message?)` — throws an AssertionError if `value` is falsy.
                - `assert.equal(actual, expected, message?)` — shallow equality check (`==` or `===` as your preference) that throws on mismatch.
                - `assert.deepEqual(actual, expected, message?)` — deep structural equality for plain objects/arrays.
                - `assert.throws(fn, expected?, message?)` — asserts that `fn()` throws; if `expected` is provided it may be a RegExp or constructor to test the thrown error.
            Provide a small `AssertionError` class that includes `.message` and `.stack` and is thrown on assertion failures. Keep this dependency-free and small — do not pull in `chai` or other assertion libraries.
        *   It must also implement a `debounce` utility function (e.g., with a 500ms delay).

*   **Task 1.3.3: Sequential Test Execution Engine**
    *   Upon receiving the task, the worker will create a debounced function, `reportState`, which sends the unified `EVENT_RUN_STATE_UPDATE` message to the Supervisor (see Message Flow 2.3).
    *   It will then iterate through the `files` array in a `for...of` loop.
    *   **Inside the loop**, for each file path, it will run the test, capture the result, add it to a local `results` array, and call `reportState()`.

*   **Task 1.3.4: Reporting the Final State**
    *   After the loop completes, the worker will make one final, non-debounced call to `reportState()` to ensure the last and complete state is sent immediately.

## 2. System Messaging & Data Contracts (Single-Worker, Unified State)

*   **2.1. Link 1: Orchestrator → Supervisor (`CMD_RUN_TESTS`)**
    *   **Mechanism:** JSON response to a long-polling `GET` request.
    *   **Data (JSON Body):**
        ```json
        { 
          "type": "CMD_RUN_TESTS",
          "files": ["/path/one.test.js", "/path/two.test.js"]
        }
        ```

*   **2.2. Link 2: Supervisor → Worker (`TASK_EXECUTE_RUN`)**
    *   **Mechanism:** `worker.postMessage()` with canvas transfer.
    *   **Data:**
        ```javascript
        {
          type: 'TASK_EXECUTE_RUN',
          files: string[],         // The full array of test scripts to run.
          canvas: OffscreenCanvas
        }
        ```

*   **2.3. Link 3: Worker → Supervisor (`EVENT_RUN_STATE_UPDATE`)**
    *   **Mechanism:** `self.postMessage()`. This single message type is sent both periodically and upon final completion.
    *   **Data:**
        ```javascript
        {
          type: 'EVENT_RUN_STATE_UPDATE',
          summary: { passed: number, failed: number, total: number, duration: number },
          results: Array<{ status: string, name: string, duration: number, error?: string }>
        }
        ```

*   **2.4. Link 4: Supervisor → Orchestrator (`REPORT_RUN_COMPLETED`)**
    *   **Mechanism:** `fetch POST` with a JSON body (REPL protocol).
    *   **Data (JSON Body):**
        ```json
        {
          "ok": true,
          "value": { /* The exact payload from the final EVENT_RUN_STATE_UPDATE message */ }
        }
        ```
