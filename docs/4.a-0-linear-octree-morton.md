# Linear Octree (LBVH) in Morton order

[See Plans and alternatives](4-refactoring-options.md) for context.


Below is a **code‑ready, high‑level plan** for replacing your BH far‑field with a **Particle–Mesh (PM) / FFT** solver (“Plan A: Grid/FFT/TreePM”). It **reuses your current 3D‑grid slicing**, additive blending, pass orchestration, and integration passes. The deliverable is *function signatures* and *pseudocode* only—no real JS—plus all math/format stipulations needed to implement.

> Reused building blocks
> • **3D grid slicing in a 2D texture** (Z‑slices arranged in a tilesheet)—exactly the mapping already used by your aggregation and traversal shaders.  
> • Full‑screen pass vertex shader for raster compute. 
> • Per‑frame pipeline & resource lifecycle in `ParticleSystem`. 
> • Additive blending to float textures (assume `EXT_float_blend` available). Your context probing is already wired. 
> • Existing integration passes for velocity and position.  

---

## 0) Scope, invariants, and choices

**Boundary mode.** Choose one (affects green’s function and “k” definition):

* `periodic` (recommended to start): the domain wraps (standard PM).
* `isolated`: use **zero‑padding convolution** on a doubled grid per axis (memory/time ↑8×) to emulate open boundaries.

**Assignment kernel (mass deposition):** default `CIC` (tri‑linear). Optional `TSC`.
**Deconvolution:** optional; if enabled, divide spectral density by the assignment window (W(\mathbf{k})) (cap near Nyquist).
**Long/short split:** smooth **Gaussian in k‑space** with scale (r_s) (“PM/TreePM split”).
**Near‑field:** local direct sum over a few L0 cells (2–3 cell radius) with complementary short‑range kernel (see §5).

---

## 1) API surface (new module)

```ts
// Initialization / teardown
function pmInit(psys: ParticleSystem, opts: PMOptions): void
function pmDispose(psys: ParticleSystem): void

// Per-frame entrypoint (replaces BH far-field in step())
function pmComputeFarField(psys: ParticleSystem): void

// Optional short-range correction (kept small and local)
function p3mNearFieldCorrection(psys: ParticleSystem): void

// Debug & validation
function pmSanityChecks(psys: ParticleSystem): void
function pmProfileLabels(): string[]  // e.g. ["pm_clear","pm_deposit","pm_fft_x",...]
```

```ts
type PMOptions = {
  gridSize: 64 | 128,                 // N per axis for the physical domain (matches your 64³ L0 nicely)
  slicesPerRow?: number,               // default: gridSize / 8 (so 64→8 as you use today)
  boundaryMode: 'periodic' | 'isolated',
  assignment: 'CIC' | 'TSC',
  deconvolveAssignment: boolean,       // true once stable
  splitRadiusCells: number,            // e.g. 1.0–1.5 (controls Gaussian S(k)=exp(-(k r_s)^2))
  nearFieldRadiusCells: 2 | 3,         // small neighborhood (direct sum)
  softening: number,                   // reuse psys.options.softening for near-field
  G: number,                           // reuse psys.options.gravityStrength
  gradientInKSpace: boolean            // true: compute ĝ=i k φ̂; false: ∇φ in real space
}
```

> `ParticleSystem.step()` changes: call `pmComputeFarField(psys)` instead of `pipelineCalculateForces(psys)`; keep the existing integration passes. Optionally call `p3mNearFieldCorrection(psys)` between force and integration.   

---

## 2) Data layout & textures (sliced 3D on 2D sheet)

Re‑use your voxel→texel mapping (Z‑slice tiling); keep texture sizes `N*slicesPerRow` as you do now. 

**New persistent textures (created in `pmInit`)**

* `pmMassGrid` : real scalar field, one 2D texture representing 3D ( \rho(\mathbf{x}) ) (units: mass per cell).
* `pmRhoSpectrum` : complex 3D spectrum of density, stored as **RG32F** (R=real, G=imag).
* `pmPhiSpectrum` : complex potential spectrum (RG32F).
* `pmAccelSpectrumX/Y/Z` : complex spectra of acceleration components (3× RG32F) if `gradientInKSpace`.
* `pmAccelX/Y/Z` : real 3D acceleration fields (g_x,g_y,g_z) in real space (3× R32F or pack into RGB32F).
* `kTableX/Y/Z` : 1D LUT textures of wave numbers (size N; for `isolated` zero‑padded size 2N).

**Transient ping‑pong buffers** for FFT passes (two copies of each complex field).

> You already allocate multi‑level textures; PM needs just **one level** (the physical grid). You can bypass the pyramid and reuse the same slicing math and FBO handling you use today.  

---

## 3) Per‑frame pipeline (pseudocode)

```pseudo
function pmComputeFarField(psys):
  beginProfile("pm_clear")
  clear(pmMassGrid)                               // gl.clear on grid FBO
  endProfile()

  beginProfile("pm_deposit")
  pmDepositMassCIC(psys)                          // additive blend from particles → pmMassGrid
  endProfile()

  beginProfile("pm_fft")
  rhoSpec = fft3D_forward(pmMassGrid)             // Stockham 1D passes: X→Y→Z
  endProfile()

  beginProfile("pm_poisson")
  if opts.deconvolveAssignment:
     rhoSpec *= 1 / W_assignment(k)^          // cap near Nyquist to avoid noise
  phiSpec = (-4πG) * rhoSpec / k_eff^2         // set phiSpec(k=0)=0
  // Apply smooth long-range filter (Gaussian split)
  phiSpec *= S(k) where S(k) = exp(- (k * r_s)^2)
  endProfile()

  beginProfile("pm_gradient")
  if opts.gradientInKSpace:
     gxSpec = (i * kx) * phiSpec
     gySpec = (i * ky) * phiSpec
     gzSpec = (i * kz) * phiSpec
  else:
     // will finite-difference ∇φ in real space after inverse FFT of φ
  endProfile()

  beginProfile("pm_ifft")
  if opts.gradientInKSpace:
     pmAccelX = fft3D_inverse(gxSpec)
     pmAccelY = fft3D_inverse(gySpec)
     pmAccelZ = fft3D_inverse(gzSpec)
  else:
     phi = fft3D_inverse(phiSpec)
     (pmAccelX,pmAccelY,pmAccelZ) = gradientRealSpace(phi)
  endProfile()

  beginProfile("pm_sample")
  sampleAccelAtParticles(psys, pmAccelX/Y/Z)      // tri-linear, writes to forceTexture (additive)
  endProfile()
```

Optionally:

```pseudo
function p3mNearFieldCorrection(psys):
  // Local direct sum within R cells; subtract the smoothed long-range component
  // to prevent double-counting (see §5), write into forceTexture (additive)
```

> `forceTexture` is the same accumulation target you already use before `vel_integrate.frag.js`/`pos_integrate.frag.js`.  

---

## 4) Pass‑level function signatures

```ts
// 3D grid utilities (reuse your mapping and constants)
function gridMappingFrom(psys: ParticleSystem): GridMapping
// contains voxelToTexel(), texelToVoxel(), worldToVoxel(), voxelSize, etc. (same math you use in aggregation/traversal) :contentReference[oaicite:15]{index=15} :contentReference[oaicite:16]{index=16}
```

```ts
// Mass deposition (CIC/TSC) — runs as a point draw over Nparticles with additive blending
function pmDepositMassCIC(psys: ParticleSystem): void
function pmDepositMassTSC(psys: ParticleSystem): void
```

```ts
// FFT passes (Stockham 1D) — all three axes share same shader with axis parameter
function fft3D_forward(realGridTex: Tex2D /*R32F*/): Tex2D /*RG32F*/ 
function fft3D_inverse(complexGridTex: Tex2D /*RG32F*/): Tex2D /*R32F*/

// Under the hood (not public):
function fft1D_axisPass(axis: 'x'|'y'|'z', stage: int, src: Tex2D, dst: Tex2D, dir: +1|-1): void
function fftBitPermute(axis: 'x'|'y'|'z', src: Tex2D, dst: Tex2D): void
function fftTwiddleLUTInit(N: int): void          // precompute in a 1D texture
```

```ts
// Spectral math
function pmMakeWaveNumberLUT(N: int, L: vec3, boundaryMode: 'periodic'|'isolated'): { kxTex, kyTex, kzTex }
function pmApplyGreensFunction(rhoSpec: Tex2D, opts: PMOptions): Tex2D   // returns phiSpec
function pmSpectrumMultiplyByIK(phiSpec: Tex2D): { gxSpec, gySpec, gzSpec }
```

```ts
// Real-space gradient (if not using k-space)
function gradientRealSpace(phiReal: Tex2D): { ax: Tex2D, ay: Tex2D, az: Tex2D }
```

```ts
// Sampling
function sampleAccelAtParticles(psys: ParticleSystem, ax: Tex2D, ay: Tex2D, az: Tex2D): void
```

```ts
// Short-range correction (optional P3M)
function p3mNearFieldCorrection(psys: ParticleSystem): void
// Implementation mirrors your L0 neighborhood sweep, with altered kernel and small radius. :contentReference[oaicite:17]{index=17}
```

---

## 5) Math & kernels (what to code into shaders)

**5.1 Mass assignment** (to build ( \rho(\mathbf{x}) ))

* **CIC** (default): distribute each particle’s mass to its 8 surrounding grid nodes with tri‑linear weights.
* **TSC** (optional): 27‑node support with a triangular kernel; lower aliasing.

The **assignment window** in Fourier space (per axis, grid spacing ( \Delta )):

* ( W_\text{CIC}(k_\alpha) = \mathrm{sinc}^2!\left(\frac{k_\alpha \Delta}{2}\right) )
* ( W_\text{TSC}(k_\alpha) = \mathrm{sinc}^3!\left(\frac{k_\alpha \Delta}{2}\right) )

If `deconvolveAssignment`, divide (\hat{\rho}) by ( W(\mathbf{k}) = \prod_\alpha W(k_\alpha) ) (cap near Nyquist to avoid amplifying noise).

**5.2 Wave numbers and discrete operators**

* **Periodic**: ( k_\alpha(n) = \frac{2\pi}{L_\alpha}\times \begin{cases} n & 0\le n \le N/2 \ n-N & N/2<n<N \end{cases} )
* **Isolated** (padded 2N grid): same definition on the padded domain.

Use a **discrete Laplacian** to reduce grid‑scale artifacts in Poisson:
( k_\text{eff}^2(\mathbf{k}) = \sum_\alpha \left(\frac{2}{\Delta_\alpha}\sin\frac{k_\alpha \Delta_\alpha}{2}\right)^2 )

**5.3 Poisson in spectral space**

* Density spectrum: ( \hat{\rho}(\mathbf{k}) = \text{FFT}[\rho(\mathbf{x})] )
* Potential spectrum: ( \hat{\phi}(\mathbf{k}) = -\frac{4\pi G}{k_\text{eff}^2} \cdot \hat{\rho}(\mathbf{k}) \cdot S(\mathbf{k}) )
* **Zero mode**: set ( \hat{\phi}(\mathbf{0}) = 0 ) (remove uniform acceleration).

**5.4 Smooth long/short split** (TreePM‑style)

* **Gaussian**: ( S(\mathbf{k}) = \exp!\big(- (k r_s)^2\big) ) with ( r_s = \text{splitRadiusCells} \times \Delta ).
  Long‑range = PM (smoothed), Short‑range = complement.

**Short‑range correction** kernel (optional but recommended for accuracy near neighbors):

Real‑space complementary force for a particle pair at separation ( r ) (Ewald/Gaussian split):

[
\mathbf{F}_\text{SR}(r) = -G,m_1 m_2,\frac{\mathbf{r}}{r^3}
\left[
\operatorname{erfc}!\left(\frac{r}{2r_s}\right)

* \frac{r}{\sqrt{\pi} r_s}\exp!\left(-\frac{r^2}{4 r_s^2}\right)
  \right].
  ]

Compute this for ( r \le R_\text{nf} = \text{nearFieldRadiusCells}\times\Delta ). Accumulate via the **L0 neighborhood loop** you already have (direct sum over nearby voxels / particles) into `forceTexture`. 

**5.5 Acceleration**

* In k‑space: ( \hat{\mathbf{g}}(\mathbf{k}) = i,\mathbf{k},\hat{\phi}(\mathbf{k}) )
* In real space: central differences on ( \phi(\mathbf{x}) ) using your 3D grid (Z‑slice mapping).

---

## 6) Shader‑pass pseudocode sketches

> All passes are **full‑screen quads** using your `fullscreen.vert.js`; uniforms follow the same conventions (grid size, slicesPerRow, world bounds) as your current aggregation/traversal passes.   

**Mass deposition (CIC) with additive blending**

```pseudo
function pmDepositMassCIC(psys):
  bindFBO(pmMassGrid); enableBlendAddFloat()
  drawPoints(N_particles) with vertex shader mapping particle→voxel (reuse your 3D mapping)
  // each point writes its 8 CIC-weighted contributions via 8 additive writes
```

(Reuse the world→voxel math you already employ in `aggregation.vert.js`; emit only **mass** to the grid, not ∑(m·x).)  

**FFT (Stockham 1D) along axis**

```pseudo
function fft3D_forward(realGrid):
  complex = realToComplex(realGrid)
  for axis in [X,Y,Z]:
    bitPermute(complex, axis)
    for stage s in 0..log2(N)-1:
      fft1D_axisPass(axis, s, src=complex, dst=ping)
      swap(ping, complex)
  return complex
```

**Apply Green’s function + filters**

```pseudo
function pmApplyGreensFunction(rhoSpec, opts):
  phiSpec = createComplex()
  for each spectral texel k:
    if k == 0: phiSpec[k] = 0
    else:
      rhoK = rhoSpec[k]
      if opts.deconvolveAssignment:
        rhoK *= 1 / W_assignment(k)         // clamp at Nyquist
      phiSpec[k] = (-4π G / k_eff^2(k)) * rhoK * exp(-(k * r_s)^2)
  return phiSpec
```

**Gradient & inverse FFT**

```pseudo
function pmSpectrumMultiplyByIK(phiSpec):
  gxSpec = (i * kx) * phiSpec
  gySpec = (i * ky) * phiSpec
  gzSpec = (i * kz) * phiSpec
  return {gxSpec, gySpec, gzSpec}

function fft3D_inverse(complexGrid):
  // symmetric to forward with dir=-1 and proper normalization (1/N³)
  ...
```

**Sample acceleration at particles (tri‑linear)**

```pseudo
function sampleAccelAtParticles(psys, ax, ay, az):
  bindFBO(psys.forceTexture); enableBlendAddFloat()
  drawPoints(N_particles):
    p = read position from u_positions
    (vx,vy,vz) = worldToVoxel(p)
    gx = trilinear(ax, vx,vy,vz)  // using your voxel→texel mapping
    gy = trilinear(ay, vx,vy,vz)
    gz = trilinear(az, vx,vy,vz)
    writeAdd(vec3(gx,gy,gz))      // accumulate far-field
```

**Short‑range correction (direct, local)**

```pseudo
function p3mNearFieldCorrection(psys):
  bindFBO(psys.forceTexture); enableBlendAddFloat()
  drawPoints(N_particles):
    p = read position
    for each neighbor cell within R_nf around voxel(p):
      for each particle j in that cell:
        r = p - x_j
        if |r| <= R_nf:
          Fsr = ewaldShortRangeForce(r, r_s, softening)
          writeAdd(Fsr)
```

(Neighborhood iteration can reuse your L0 neighborhood pattern in `traversal.frag.js`, but now it loops particles within those voxels; start with “one particle per texel” assumption, expand later if you keep lists.) 

---

## 7) Integration with your existing pipeline

* **Initialization** (`ParticleSystem.init()`): call `pmInit(psys, opts)` after your existing `createTextures()` so PM textures & LUTs allocate alongside. 
* **Per frame** (`ParticleSystem.step()`):

  * Skip `buildQuadtree()` and `pipelineCalculateForces(psys)` when PM is active.
  * Call `pmComputeFarField(psys)` (and optionally `p3mNearFieldCorrection(psys)`), then `pipelineIntegratePhysics(psys)` as you already do.   
* **World bounds**: keep your periodic GPU readback bounds update; PM uses the same `worldMin/worldMax` uniforms you already pass into aggregation/traversal.  

---

## 8) Tuning & sanity

* **Grid size (N)**: start with 64³ (you already run that L0), then test 128³ if memory allows.
* **Normalization**: ensure inverse FFT divides by (N^3).
* **DC mode**: `phi(0)=0`; check that mean acceleration is ~0 for isolated masses.
* **r_s**: start with `splitRadiusCells = 1.0`. If near‑field is disabled, increase to 1.5–2.0 to avoid cuspiness.
* **Profiling tags**: wrap each pass in your `GPUProfiler` like you already do for aggregation/traversal/integration. 
* **Integrator**: keep your current passes; consider switching the order to KDK (symplectic) later to further stabilize energy/momentum (wiring change only).  

---

## 9) What you can delete/skip

* The **pyramid reduction** and multi‑level sampling used by BH are **not required** for PM. Leave the code in place behind a feature flag; PM uses only the L0‑style 3D grid (single level).  

---

## 10) Minimal milestones to land Plan A

1. **Mass grid pass** (CIC, additive blend) writing to a sliced 2D texture. (Uses your aggregation mapping; emit mass only.)  
2. **3D FFT** (X→Y→Z) with Stockham butterflies, ping‑pong textures, and 1D twiddle LUT. (Use your fullscreen pass plumbing.) 
3. **Poisson spectral multiply** with Gaussian `S(k)` and deconvolution toggle.
4. **Inverse FFT to acceleration** (k‑space gradient is simplest/cleanest).
5. **Tri‑linear sampling at particles → `forceTexture` (additive)**; integrate with your existing velocity/position passes.  
6. **(Optional) Short‑range correction** via your L0 neighborhood loop, now with the Ewald short‑range kernel and small radius. 

This gives you a **smooth, non‑stepped** far/near split by construction, a large perf headroom for bigger (N), and a clear path to accuracy tuning via (N, r_s), assignment kernel, and near‑field radius—all without switching APIs or changing your renderer.
