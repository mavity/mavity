# Integration Testing for Particle Systems

## Overview

This document defines the conceptual approach and test structure for integration testing of complete particle systems. While kernel-level unit tests validate individual shader passes, integration tests validate entire computational pipelines across multiple scales, configurations, and physical scenarios.

## Design Philosophy

Integration tests verify emergent correctness properties that span multiple kernels:
- Conservation laws across complete simulation steps
- Numerical stability over many iterations
- Correctness against known analytical solutions
- Performance characteristics under various loads
- GPU resource handling and memory safety

Tests avoid code duplication through test utilities while remaining declarative and intention-revealing. Each test isolates one scenario or property.

## Test Categories

### 1. Correctness Tests

Validate computational accuracy against ground truth.

**Small-Scale Validation** — 5-10 tests per system
- Single particle (zero force)
- Two-body problem (mutual attraction)
- Three-body configurations (Lagrange points, Pythagorean)
- Ten-body clustered arrangement
- Empty system (boundary condition)

**Large-Scale Validation** — 3-5 tests per system
- Hundred particles uniform distribution
- Thousand particles clustered
- Ten thousand particles with hierarchy

**Known Solutions** — 4-6 tests per system
- Solar system (8 planets, analytical ephemeris)
- Binary orbit (circular, elliptical, parabolic)
- Plummer sphere (known density profile)
- Hernquist model (dark matter halo)
- Uniform sphere collapse (free-fall time)
- Rotating disk (Keplerian velocities)

### 2. Conservation Tests

Verify fundamental physics invariants under practical conditions with approximate tolerances.

**Per System Type** — 3-4 tests
- Total momentum conservation (no external forces, over 100-1000 steps)
- Angular momentum conservation (symmetric initial conditions, over 100-1000 steps)
- Energy conservation (isolated systems, accounting for softening effects, over 100-1000 steps)
- Mass conservation (spectral/mesh methods only, essential validation)

**Note:** Exact conservation cannot be expected due to time integration errors, softening, and numerical dissipation. Each test implementation determines reasonable tolerances based on the integration scheme and test scenario.

### 3. Stability Tests

Ensure numerical stability and absence of pathologies.

**Per System Type** — 4-5 tests
- Long integration (10,000 steps without divergence)
- Close encounters (softening validation)
- Extreme mass ratios (1:1000 mass difference)
- Boundary stress (particles near world limits)
- Rapid configuration changes (sudden mass injection)

### 4. Convergence Tests

Validate that refinement improves accuracy.

**Grid-Based Methods (Mesh, Spectral)** — 3-4 tests per system
- Grid resolution convergence (32³ → 64³ → 128³)
- Assignment order convergence (NGP → CIC → TSC)
- Split parameter convergence (near/far field balance)
- Timestep refinement (dt/2, dt/4)

**Hierarchical Methods (Monopole, Quadrupole)** — 3-4 tests per system
- Theta parameter convergence (0.8 → 0.5 → 0.3)
- Softening length convergence
- Near-field cutoff convergence
- Multipole order (monopole → quadrupole)

### 5. Resource Management Tests

Validate GPU resource lifecycle.

**Per System Type** — 1-2 tests
- Creation/disposal cycle (10 create/dispose iterations)
- Texture reuse (externally managed textures preserved)

## Test Organization

### File Structure and Grouping

Tests are organized by scenario type, with each group corresponding to a separate test file:

```
particle-system/
  __integration-tests__/
    test-utils-integration.js            # Shared utilities
    scenarios/
      two-body.js                        # Reusable scenario generators
      solar-system.js
      plummer-sphere.js
      ...
    monopole/
      monopole.small-scale.test.js       # Tests 1-4: single particle, two-body, three-body, cluster
      monopole.large-scale.test.js       # Tests 1-3: 100, 1k, 10k particles
      monopole.known-solutions.test.js   # Tests 1-3: solar system, binary orbit, Plummer
      monopole.conservation.test.js      # Tests 1-4: momentum, angular momentum, energy, mass
      monopole.stability.test.js         # Tests 1-4: long integration, close encounters, mass ratios, boundaries
      monopole.convergence.test.js       # Tests 1-3: theta, softening, near-field
      monopole.resource-mgmt.test.js     # Tests 1-2: create/dispose cycle, texture reuse
    quadrupole/
      quadrupole.small-scale.test.js
      quadrupole.large-scale.test.js
      quadrupole.known-solutions.test.js
      quadrupole.conservation.test.js
      quadrupole.stability.test.js
      quadrupole.convergence.test.js     # Includes multipole order convergence
      quadrupole.resource-mgmt.test.js
    spectral/
      spectral.small-scale.test.js
      spectral.large-scale.test.js
      spectral.known-solutions.test.js
      spectral.conservation.test.js
      spectral.stability.test.js
      spectral.convergence.test.js       # Grid, assignment, split, timestep
      spectral.resource-mgmt.test.js
    mesh/
      mesh.small-scale.test.js
      mesh.large-scale.test.js
      mesh.known-solutions.test.js
      mesh.conservation.test.js
      mesh.stability.test.js
      mesh.convergence.test.js           # Grid, assignment, near-field, timestep
      mesh.resource-mgmt.test.js
```

Each test file contains related tests as defined in the test categories above. For example, `monopole.known-solutions.test.js` contains 3-4 tests for solar system, binary orbit, Plummer sphere, and one additional known solution.

### Shared Utilities

**test-utils-integration.js** provides:
- Scenario generators (two-body, solar system, random distributions)
- Physics validators (conservation law calculations, energy calculations)
- Statistical assertions (distribution comparisons)
- Time integration helpers (multi-step execution with snapshots)
- Snapshot comparison utilities

## Test Count Summary

### Monopole System (17-21 tests)
- Correctness: 8-10 (small + large + 2-3 known solutions)
- Conservation: 3
- Stability: 4
- Convergence: 3
- Resource: 2

### Quadrupole System (17-21 tests)
- Correctness: 8-10 (including quadrupole-specific cases)
- Conservation: 3
- Stability: 4
- Convergence: 4 (includes multipole order)
- Resource: 2

### Spectral System (18-24 tests)
- Correctness: 10-12 (grid-specific scenarios)
- Conservation: 3
- Stability: 4
- Convergence: 3 (grid + assignment + split)
- Resource: 2

### Mesh System (18-24 tests)
- Correctness: 10-12 (mesh-specific scenarios)
- Conservation: 3
- Stability: 4
- Convergence: 3 (grid + assignment + near-field)
- Resource: 2

## Validation Criteria

Each test implementation determines appropriate tolerances and assertions based on the specific scenario. The test itself documents what constitutes success for that scenario, accounting for the integration scheme, physics parameters, and method-specific characteristics. Approximate conservation laws should reflect realistic physical behavior under the integration method and parameters used.

## Implementation Approach

Test implementation should follow this sequence:

1. **Build shared infrastructure** — Create test-utils-integration.js with scenario generators and physics validators
2. **Implement small-scale tests** — Quick validation of basic correctness for all systems
3. **Implement large-scale tests** — Validate scaling to realistic particle counts
4. **Add known solutions** — Implement 3-6 known-solution tests per system with multi-timescale validation
5. **Add conservation tests** — Validate approximate conservation laws
6. **Add stability tests** — Long runs, extreme conditions, edge cases
7. **Add convergence tests** — Validate refinement behavior
8. **Add resource management** — Ensure clean resource lifecycle
9. **Validate against legacy** — Cross-check new against existing implementations once available

## Relationship to Unit Tests

**Unit tests (kernel-level):**
- Single shader pass
- Small test textures (4×4, 8×8)
- Immediate validation
- Fast execution (milliseconds)
- Isolation from other kernels

**Integration tests (system-level):**
- Complete computational pipeline
- Realistic problem sizes
- Multi-step evolution
- Moderate execution (seconds)
- Validates kernel composition

Both layers are necessary. Unit tests catch shader bugs early. Integration tests catch emergent issues in pipeline composition, numerical stability, and physics correctness.

## Test Execution

Integration tests execute via:

- **Browser environment:** Direct execution in three-g pages with WebGL2 support
- **[Daebug REPL](7.3-repl-chat.md):** Interactive testing and debugging via markdown test harness
- **Manual invocation:** Direct JavaScript function calls during development

## References

- Kernel unit testing: `docs/0.1-unit-testing-glsl.md`
- Kernel contract: `docs/8-webgl-kernels.md`
- Test harness: [docs/7.3-repl-chat.md](7.3-repl-chat.md)
- Monopole implementation: `particle-system/gravity-multipole/`
- Spectral validation: `particle-system/gravity-spectral/debug/test-runner.js`
- Test utilities: `particle-system/test-utils.js`

### Solar System Test

Eight planets plus the Sun (9 bodies) initialized from JPL Horizons ephemeris for a known epoch. The test integrates the system over multiple timescales and validates planet positions at regular intervals.

The test samples positions at hourly intervals, aggregates them into daily means, then validates all daily positions over successive periods (1 day, 1 month, 1 year). A single assertion validates the entire time series against expected accuracy, capturing enough diagnostic data to assess failure modes if positions diverge beyond reasonable bounds.

This test validates: long-range forces, mass hierarchy, stability over extended periods, and consistency across multiple timescales.

### Binary Orbit Test

Two equal masses in circular orbit around their common center of mass. The analytical solution is a constant orbital radius and constant angular velocity.

The test validates the orbital period, orbit circularity (radius variance), and energy constancy over 100+ orbits. Position snapshots are captured at regular intervals and compared to the analytical trajectory.

This test validates: two-body dynamics, time integration accuracy, and long-term orbital stability.

### Plummer Sphere Test

1000 particles initialized in a Plummer sphere density profile at virial equilibrium. The test evolves the system and validates that the radial density profile remains stable and matches the Plummer model.

Position snapshots are compared against the theoretical profile using binned radial statistics. The test checks that velocity dispersion and velocity anisotropy remain consistent with the initial equilibrium.

This test validates: many-body equilibrium, force isotropy, numerical stability in self-gravitating systems.

### Uniform Sphere Collapse Test

1000 particles initially at rest in a uniform sphere. The analytical free-fall time is t_ff = sqrt(3π/32Gρ₀). The test validates that the system collapses on the correct timescale and maintains self-similar structure.

Position and velocity statistics are compared at fractional collapse times (25%, 50%, 75% of t_ff). The test checks that the collapse profile matches self-similar predictions.

This test validates: self-gravity, symmetry preservation, energy conservation in zero-softening limit.

### Rotating Disk Test

1000 particles in a thin disk initialized with Keplerian velocities. The test validates that the disk remains stable without artificial heating or decay.

Position and velocity distributions are tracked over 100+ rotation periods. The scale height and velocity dispersion are monitored to detect heating or cooling.

This test validates: differential rotation, numerical stability in rotating systems, conservation of rotational structure.

### Hernquist Model Test

1000 particles in a Hernquist profile (dark matter halo-like density). The test validates that an initially relaxed Hernquist system remains stable over long timescales.

Radial density profile and velocity statistics are monitored. The test checks for artificial heating, mass segregation, or profile evolution.

This test validates: realistic astrophysical profiles, stability in steep potential gradients, absence of spurious dynamics.

## Out of Scope: Regression Tests

Regression tests prevent unintended behavioral changes. While valuable, they are deferred to a later phase after integration tests establish baseline correctness:

- Golden master comparison (fixed seed, 100 steps)
- Cross-validation against legacy implementation
- Snapshot tests at known timesteps

Regression tests require:
1. All correctness and stability tests passing
2. Established golden master snapshots
3. CI infrastructure for automated baseline comparison
4. Clear policies for when regressions are acceptable (refactoring, optimization)

Regression tests should be added once the integration test suite is mature and new implementations are stable.
