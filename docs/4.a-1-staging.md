# Staging of Plan A

[See Linear Octree / Morton](4.a-0-linear-octree-morton.md) and [Plans and alternatives](4-refactoring-options.md) for context.

You can build a **stage‑isolated debug mode** where any step of the PM/FFT pipeline runs **without** the rest of the particle system and with **synthetic stimuli** and **independent sinks (“unloaders”)**. Below is a concrete, code‑shaped plan: only **function signatures** and **pseudocode**, wired to the structure you already have (passes, textures, profiling), and reusing your 3D grid slicing & pass orchestration. I assume `EXT_float_blend` is present, so all additive writes go straight to float targets. 

---

## 0) What “unloaders” are

**Unloaders** are pluggable **sinks** and **sources** for each stage:

* **Sources**: replace the upstream dependency of a stage (e.g., particle positions → mass grid) with a **synthetic generator** or a **recorded snapshot**.
* **Sinks**: capture a stage’s outputs to **debug views**, **reduction metrics**, **readback buffers**, or **no‑op**; optionally **stop** the pipeline there.

Stage isolation therefore means: **(source override) → run stage → (sink/unloader)**, without touching the rest of the system.

---

## 1) Stage graph (Plan A / PM‑FFT)

Stages you’ll want to isolate:

1. **Mass deposition** (positions → `pmMassGrid`)
2. **FFT forward** (`pmMassGrid` → `rhoSpectrum`)
3. **Poisson & filters** (`rhoSpectrum` → `phiSpectrum`)
4. **k‑space gradient** (`phiSpectrum` → `accelSpectrumXYZ`)
5. **FFT inverse** (`accelSpectrumXYZ` → `pmAccelX/Y/Z`)
6. **Sampling** (`pmAccelX/Y/Z` → particle `forceTexture`)
7. **Near‑field correction** (local direct sum, optional)

Your code already uses a similar **pass‑graph discipline** (aggregation → pyramid reduction → traversal → integration), with profiling and GL state hygiene; we’ll fit into that framework.    

---

## 2) Debug API surface

```ts
// Global toggles (kept on the ParticleSystem to reuse your lifecycle/profiler)
type DebugPMConfig = {
  enabled: boolean,
  // Run exactly one stage with custom source/sink, without advancing the sim:
  singleStageRun?: { stage: PMStageID, source?: PMSourceSpec, sink?: PMSinkSpec },

  // Record/Replay:
  recordAfterStage?: PMStageID,          // capture outputs into a snapshot bank
  replayBeforeStage?: PMStageID,         // feed snapshot as source to this stage

  // Safety & probes:
  assertInvariants?: boolean,            // run mass/DC/Parseval checks
  drawOverlays?: boolean,                // show grids/slices or spectrum heatmaps
};

type PMStageID =
  | 'pm_deposit'
  | 'pm_fft_forward'
  | 'pm_poisson'
  | 'pm_gradient'
  | 'pm_fft_inverse'
  | 'pm_sample'
  | 'pm_nearfield';

function pmDebugInit(psys: ParticleSystem, cfg: DebugPMConfig): void
function pmDebugDispose(psys: ParticleSystem): void

// Run a single stage in isolation (does not call integrate or other stages)
function pmDebugRunSingle(psys: ParticleSystem, stage: PMStageID, source?: PMSourceSpec, sink?: PMSinkSpec): void

// One-frame, in-place hooks (used inside pmComputeFarField):
function pmDebugBeforeStage(psys: ParticleSystem, stage: PMStageID): PMSourceSpec | null
function pmDebugAfterStage(psys: ParticleSystem, stage: PMStageID): PMSinkSpec | null
```

Your `ParticleSystem` already exposes **profiling**, **unbind helpers**, texture creation, and a clear **per‑frame** pipeline; the debug module plugs in *alongside* that. 

---

## 3) Source specifications (to unplug upstream)

```ts
type PMSourceSpec =
  | { kind: 'live' }                                   // use real upstream data
  | { kind: 'snapshot', key: string }                  // use stored textures by key
  | { kind: 'synthetic', synth: PMSyntheticSpec };     // generate known inputs
```

```ts
type PMSyntheticSpec =
  // For deposition stage: bypass positions → write mass grid directly
  | { type: 'gridImpulse', centerVoxel: ivec3, mass: float }
  | { type: 'twoPointMasses', a: ivec3, b: ivec3, ma: float, mb: float }
  | { type: 'planeWaveDensity', k: ivec3, amplitude: float }   // for FFT correctness
  // For spectrum stages: directly feed spectra
  | { type: 'spectrumDelta', k: ivec3, amplitude: float }
  | { type: 'spectrumWhiteNoise', seed: int, power: float };
```

**How synthetic is used** (pseudocode):

```pseudo
function provideSource(psys, stage, spec):
  switch (stage):
    case 'pm_deposit':
      if spec.kind == 'synthetic':
        // Write directly into pmMassGrid using fullscreen quad
        drawSynthDensityToGrid(spec.synth)
      else if spec.kind == 'snapshot':
        blit(snapshot[key].pmMassGrid → pmMassGrid)
      else:
        pmDepositMassCIC(psys) // normal path

    case 'pm_fft_forward':
      if spec.kind == 'synthetic':
        drawSynthSpectrumTo(rhoSpectrum)
      else if spec.kind == 'snapshot':
        blit(snapshot[key].rhoSpectrum → rhoSpectrum)
      else:
        rhoSpectrum = fft3D_forward(pmMassGrid)
  ...
```

You already have the **fullscreen quad** vertex shader and 3D grid mapping; reuse them to draw synthetic patterns into the sliced grid.  

---

## 4) Sink (“unloader”) specifications (to capture outputs and stop)

```ts
type PMSinkSpec =
  | { kind: 'noop' }                         // ignore outputs
  | { kind: 'snapshot', key: string }        // store textures by key
  | { kind: 'overlay', view: PMOverlaySpec } // visualize to screen
  | { kind: 'metrics', checks: PMCheckSpec } // run invariants/reductions
  | { kind: 'readback', buffers: PMReadbackSpec }; // CPU arrays for inspection
```

```ts
type PMOverlaySpec =
  | { type: 'gridSlice', axis: 'x'|'y'|'z', index: int }  // visualize 2D slice of 3D field
  | { type: 'spectrumMagnitude', logScale: boolean }      // heatmap |F(k)|
  | { type: 'vectorGlyphs', stride: int };                // arrows for accel field
```

```ts
type PMCheckSpec = {
  // invariants/diagnostics (all GPU-side using reduction + tiny readback)
  checkMassConservation?: boolean,
  checkDCZero?: boolean,                      // φ̂(0)=0, ∑g ≈ 0
  checkFFTInverseIdentity?: boolean,          // IFFT(FFT(f)) ≈ f (RMS error)
  checkPoissonOnPlaneWave?: boolean,          // -k^2 φ̂ ≟ ρ̂
  reportLinfL2?: boolean                      // norms of residuals
};
```

You already have a **pyramid reduction shader** that sums child tiles; repurpose it to compute **global sums/energies** of grids/spectra for metrics (mass, DC, residual norms). It’s a perfect fit for **metrics sinks** (sum → sum → … → 1 texel). 

---

## 5) Snapshot bank & record/replay

```ts
type PMSnapshot = {
  pmMassGrid?: Tex2D,
  rhoSpectrum?: Tex2D,        // RG32F complex
  phiSpectrum?: Tex2D,        // RG32F complex
  accelSpectrumXYZ?: { x: Tex2D, y: Tex2D, z: Tex2D },
  pmAccelXYZ?: { x: Tex2D, y: Tex2D, z: Tex2D },
  sampledForces?: Tex2D
};

function pmSnapshotStore(psys: ParticleSystem, key: string, atStage: PMStageID): void
function pmSnapshotLoad(psys: ParticleSystem, key: string, forStage: PMStageID): PMSourceSpec
function pmSnapshotDispose(key: string): void
```

* **Record** after any stage → store the relevant textures.
* **Replay** before any stage → feed the stored textures as the stage’s source.

This lets you freeze inputs, regenerate later stages repeatedly with different shader changes, and compare **A/B** outputs deterministically.

---

## 6) Hooks in the normal per‑frame path

Integrate into your existing `ParticleSystem.step()` without affecting non‑debug runs:

```pseudo
function pmComputeFarField(psys):
  if debug.enabled and debug.singleStageRun exists:
    // Hard isolate: run exactly one stage with overrides; do not integrate
    pmDebugRunSingle(psys, debug.singleStageRun.stage, debug.singleStageRun.source, debug.singleStageRun.sink)
    return

  // Normal PM pipeline but with before/after hooks
  src = pmDebugBeforeStage(psys, 'pm_deposit');     provideSource(psys,'pm_deposit', src or {kind:'live'})
  runDeposit()
  sink = pmDebugAfterStage(psys, 'pm_deposit');     applySink(psys,'pm_deposit', sink)

  src = pmDebugBeforeStage(psys, 'pm_fft_forward'); provideSource(...)
  runFFTForward()
  sink = pmDebugAfterStage(psys, 'pm_fft_forward'); applySink(...)

  src = pmDebugBeforeStage(psys, 'pm_poisson');     provideSource(...)
  runPoisson()
  sink = pmDebugAfterStage(psys, 'pm_poisson');     applySink(...)

  // ...gradient, inverse, sampling, nearfield similar...
```

Your profiler is kept intact (`begin/end` around each stage) so you can correlate **metrics** and **overlays** with **GPU timings** per stage. 

---

## 7) Concrete unloaders per stage

**A. Mass deposition (`pm_deposit`)**

* **Synthetic**: draw a **delta** at a voxel, a pair of masses, or a **plane wave density**; uses your 3D sliced‑grid mapping from `aggregation.vert.js`. 
* **Metrics**: reduce **∑ρ** and verify equals **∑ particle masses**; compute **center of mass**. Use your reduction pass pattern. 
* **Overlay**: show a **slice heatmap**; or project the mass grid back to a point cloud color overlay (reusing your render path).  

**B. FFT forward (`pm_fft_forward`)**

* **Synthetic**: feed a **spectrum delta** at known (k) (should inverse‑FFT to a cosine in real space).
* **Metrics**: **Parseval** check (energy before/after), **roundtrip** check with IFFT.

**C. Poisson & filters (`pm_poisson`)**

* **Synthetic**: feed a single **plane wave density**; expected ( \hat\phi = -4\pi G,\hat\rho/k_\text{eff}^2 ).
* **Metrics**: DC mode is zero; report **L∞/L²** error of (-k_\text{eff}^2 \hat\phi - 4\pi G\hat\rho).

**D. k‑gradient (`pm_gradient`)**

* **Overlay**: spectrum magnitude of (i\mathbf{k}\hat\phi).
* **Metrics**: check **Hermitian symmetry** (for real fields).

**E. IFFT to real acceleration (`pm_fft_inverse`)**

* **Overlay**: vector glyphs (stride) of ( \mathbf{g}(\mathbf{x}) ) on a slice; or 3 heatmaps for components.
* **Metrics**: (\sum \mathbf{g} \approx 0) (no DC accel).

**F. Sampling (`pm_sample`)**

* **Synthetic source**: feed a **known analytic acceleration field** (e.g., constant field) to test tri‑linear sampling accuracy.
* **Sink**: **readback** a small patch of the force texture to verify units and scaling. Your integration shaders will accept that texture unchanged. 

**G. Near‑field (`pm_nearfield`)**

* **Synthetic**: single cell with multiple particles.
* **Metrics**: compare against tiny **direct (O(n^2))** CPU reference for 64–256 particles (debug‑only path).
* **Overlay**: heatmap of near‑field contribution magnitude.

---

## 8) Minimal invariants & checks (all GPU‑side where possible)

```ts
function pmCheckMassConservation(): void
// uses a reduction over pmMassGrid to a single texel and compares with
// reduction over positions texture mass channel (sum of pos.w). :contentReference[oaicite:15]{index=15} :contentReference[oaicite:16]{index=16}

function pmCheckDCZero(): void
// reads phiSpec[0,0,0] (or accelSpec DC) and asserts ~0; tiny readback of 1 texel

function pmCheckFFTInverseIdentity(): void
// run forward+inverse on pmMassGrid (or a synthetic f), compute RMS error via reduction

function pmCheckPoissonOnPlaneWave(k): void
// synthesize plane wave ρ, run Poisson, reduce norm of residual -k_eff^2 φ̂ - 4πG ρ̂
```

---

## 9) Visual overlays (unloaders that draw)

```ts
function pmOverlayGridSlice(psys, field: 'rho'|'phi'|'gx'|'gy'|'gz', axis, index, logScale): void
// Render selected slice to the default framebuffer using fullscreen quad. 
// Reuse your fullscreen VAO and shader plumbing. :contentReference[oaicite:17]{index=17}

function pmOverlaySpectrum(psys, spec: 'rho'|'phi', logScale): void
// Visualize |F(k)| as heatmap (2D layout consistent with your slice tiling)

function pmOverlayVectorGlyphs(psys, accelField, stride): void
// Sample accel on a coarse grid and draw points/lines; reuse your render VAO. :contentReference[oaicite:18]{index=18} :contentReference[oaicite:19]{index=19}
```

---

## 10) Integration with your existing debug helpers

You already have:

* `unbindAllTextures()`, `checkGl(tag)`, `checkFBO(tag)` → call before/after each debug stage to avoid feedback. 
* `GPUProfiler` → wrap each stage and each unloader to get timings in the same HUD you use now. 

Add:

```ts
function pmDebugLabel(psys: ParticleSystem, name: string): void
// integrates with GPUProfiler labels, e.g., "pm_deposit (synthetic)", "pm_fft_forward (replay)"
```

---

## 11) Example debug sessions (pseudocode)

**A. Verify FFT+Poisson path without particles**

```pseudo
pmDebugRunSingle(psys, 'pm_deposit',
  source = {kind:'synthetic', synth:{type:'planeWaveDensity', k:(1,0,0), amplitude:1}},
  sink   = {kind:'snapshot', key:'rho_grid'}
)

pmDebugRunSingle(psys, 'pm_fft_forward',
  source = {kind:'snapshot', key:'rho_grid'},
  sink   = {kind:'overlay', view:{type:'spectrumMagnitude', logScale:true}}
)

pmDebugRunSingle(psys, 'pm_poisson',
  source = {kind:'snapshot', key:'rho_grid'},
  sink   = {kind:'metrics', checks:{checkPoissonOnPlaneWave:true}}
)
```

**B. Sample accelerations with frozen grid**

```pseudo
// Record accel fields
debug.recordAfterStage = 'pm_fft_inverse'
pmComputeFarField(psys)   // one frame

// Now replay accel into sampler repeatedly while you tweak sampler shader:
pmDebugRunSingle(psys, 'pm_sample',
  source = {kind:'snapshot', key:'accel_real'},
  sink   = {kind:'readback', buffers:{forcePatch: region(0..16,0..16)}}
)
```

**C. Deposit sanity with particles unplugged from integration**

```pseudo
// Freeze positions: skip vel/pos integration; deposit only; visualize slices
pmDebugRunSingle(psys, 'pm_deposit',
  source = {kind:'live'},
  sink   = {kind:'overlay', view:{type:'gridSlice', axis:'z', index:32}}
)
// Run mass conservation check
pmDebugRunSingle(psys, 'pm_deposit',
  source = {kind:'live'},
  sink   = {kind:'metrics', checks:{checkMassConservation:true}}
)
```

You already have clean **integration passes** separated (`vel_integrate.frag.js`, `pos_integrate.frag.js`), so freezing the system for a debug frame is simply **not calling** the integrate pipeline when `debug.enabled && singleStageRun`.  

---

## 12) Stipulations & definitions to keep things robust

* **Texture contracts**

  * `pmMassGrid`: **R32F**, sliced 3D layout, units = **mass per cell**.
  * Spectra: **RG32F** complex (R=real, G=imag); normalization: IFFT applies **1/N³**.
  * Accel fields: **R32F** each (or RGB32F packed).
  * `forceTexture`: unchanged format & semantics (accumulated acceleration), so your **integration** needs no changes. 

* **Coordinate system**
  Reuse `worldMin/worldMax`, `voxelToTexel`, and slice tiling you already use in aggregation/traversal; it guarantees consistent addressing across all unloaders/sources.  

* **Precision**
  All compute passes run `highp` in fragments (you already do that in traversal/integration). Keep spectra in 32‑bit float for numeric headroom.  

* **Blending**
  Deposition and force accumulation always use **additive float blending** (assume present as requested). Your `aggregation.frag.js` write pattern is already “sum of weighted contributions,” same idea applies. 

---

## 13) Preparatory wiring (Plan A toggle)

- **UI toggle** Add a `Plan A` checkbox in the main demo UI next to the profiling control. Default unchecked.
- **Particle system flag** Extend `particle-system/index.js` to accept a `planA` boolean (default `false`). Pass it through to `ParticleSystem` options so shaders/pipelines can branch cleanly.
- **Toggle behavior** When the checkbox flips, dispose and reinstantiate the particle system with the new `planA` value to avoid mixed-state GPU resources.
- **DevTools hook** Attach `window.planA = (enabled) => { setToggle(enabled); applyPlanA(enabled); }` so engineers can flip modes from the console.
- **Staging usage** Once the flag exists, guard all PM/FFT staging code behind `if (psys.options.planA)` checks. With the toggle on, follow the stage-isolated workflow above using the embedded browser for debugging.

## 14) Where to put it

* A new `pm-debug/` module that **does not** mutate core state unless `debug.enabled` is true.
* A small addition in `ParticleSystem.step()` to branch into **single‑stage** path when requested. Your class already centralizes frame orchestration, profiling, and GL state resets, so it’s the right home for the hook. 

---

### Bottom line

Yes—build **stage‑isolated sources/sinks** (unloaders) with **record/replay**, **synthetic stimuli**, **GPU‑side metrics via your reduction pass**, and **visual overlays**. You can debug each FFT/Poisson/gradient/sampling step **completely unplugged** from the rest of the simulation, using the exact grid slicing, state management, and profiling infrastructure you already have.      
