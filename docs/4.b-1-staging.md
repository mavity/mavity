# Debug Unloaders

The layer that lets you **pull any pass out of the loop and run it in isolation** with synthetic inputs, saved snapshots, or recorded intermediate textures. Below is a **conceptual plan with function signatures and pseudocode only**, wired to the current architecture and files. It uses the existing profiler and debug helpers and assumes `EXT_float_blend` is present.

---

## 0) Goals

- Run any PM/FFT/TreePM sub‑pipeline **stand‑alone** (no dependency on particles or other passes).
- **Swap inputs/outputs**: live data ↔ synthetic generators ↔ saved snapshots.
- **Observe & measure**: GPU‑time, norms, RMSE, Parseval/Poisson checks, slice viewers.
- **No code duplication**: re‑use existing VAOs, FBO helpers, fullscreen quad, L0 slice mapping.

---

## 1) Debug Unloaders layer

### 1.1 Resource slots (contract)

Define a fixed set of **logical slots** that passes bind to; the unloader can override any slot.

```
enum DebugSlot {
  POSITIONS, VELOCITIES, FORCE,
  L0,                   // ∑(m·x,y,z), ∑m at 64³ sliced into 2D
  RHO_REAL,             // PM density (real, R32F)
  RHO_K,                // ρ̂(k) complex (RG32F)
  PHI_K,                // φ̂(k) complex (RG32F)
  GKX, GKY, GKZ,        // ĝ components (RG32F)
  AX, AY, AZ            // real-space accel components (R32F)
}
```

**Shape rules**

- 3D grid resources follow the **64³ sliced‑into‑2D** convention (`gridSize × slicesPerRow` → 2D size), exactly as in aggregation/traversal.
- Particle textures use existing `textureWidth × textureHeight` layout.

### 1.2 DebugUnloader API

```
class DebugUnloader {
  constructor(ps: ParticleSystem)

  // Slot routing ------------------------------------------------------------
  overrideSlot(slot: DebugSlot, source: DebugSource): void
  clearOverride(slot: DebugSlot): void
  getBoundTexture(slot: DebugSlot): Texture2D     // returns override or live

  // Isolation harness -------------------------------------------------------
  beginIsolation(tag: string): void
  endIsolation(): void

  // Snapshots ---------------------------------------------------------------
  saveSnapshot(name: string, slots: DebugSlot[]): void
  loadSnapshot(name: string): void

  // Generators (see §2) -----------------------------------------------------
  generateRhoDelta(centerVoxel: ivec3, mass: float): void
  generateRhoGaussian(centerVoxel: ivec3, sigmaCells: float, mass: float): void
  generateRhoPlaneWave(k: ivec3, amplitude: float): void
  generatePositionsLattice(step: ivec3): void

  // Observers (see §3) ------------------------------------------------------
  view3DField(slot: DebugSlot, mode: ViewMode, slice: int): void
  reduceScalar(slot: DebugSlot, op: ReduceOp): float
  compareRMSE(slotA: DebugSlot, slotB: DebugSlot): float
  probeAt(slot: DebugSlot, voxel: ivec3): vec4
}
```

- Uses the `ParticleSystem.unbindAllTextures()`, `checkGl()`, `checkFBO()` before/after each pass.
- Uses the **GPUProfiler** around isolated passes.

---

## 2) Synthetic **Generators** (inputs without the rest of the system)

Use the same **sliced 3D mapping** and fullscreen quad. Generators write directly to target grid textures.

**Signatures**

```
function genRhoDelta(ps, target: DebugSlot, centerVoxel: ivec3, mass: float): void
function genRhoGaussian(ps, target: DebugSlot, centerVoxel: ivec3, sigmaCells: float, mass: float): void
function genRhoPlaneWave(ps, target: DebugSlot, k: ivec3, amplitude: float): void
function genPositionsLattice(ps, step: ivec3): void
```

**Pseudocode**

```
genRhoDelta:
  clear(target)
  drawPointIntoSliced2D(centerVoxel) with alpha = mass (additive blend)

genRhoGaussian:
  clear(target)
  for each voxel in local window around center:
    r = |voxel - center|
    rho = mass * exp(-0.5 * (r/sigmaCells)^2) / norm
    write rho (additive)
  // implement via fullscreen pass that computes voxel coords from gl_FragCoord

genRhoPlaneWave:
  clear(target)
  for each voxel:
    phase = dot(k, voxel) * 2π / gridSize
    rho = amplitude * sin(phase) (or cos)
    write rho

genPositionsLattice:
  fill POSITIONS texture with a regular lattice inside world bounds
```

- All passes use `fullscreen.vert.js` and the voxel↔texel helpers (ported).

---

## 3) **Observers** (visualize + quantify)

**Signatures**

```
function view3DField(ps, slot: DebugSlot,
                     mode: 'real'|'imag'|'magnitude'|'phase',
                     component: 'scalar'|'x'|'y'|'z',
                     sliceIndex: int): void

function reduceScalar(ps, slot: DebugSlot, op: 'sum'|'sumSq'|'max'|'min'): float

function compareRMSE(ps, slotA: DebugSlot, slotB: DebugSlot): float

function probeAt(ps, slot: DebugSlot, voxel: ivec3): vec4
```

**Pseudocode**

```
view3DField:
  // Draw given slice to a debug target FBO using a simple tone map shader
  // Reuse slice mapping from aggregation/traversal
  drawSlice(slotTexture, sliceIndex, mode, component)

reduceScalar:
  // Multi-pass downsample using a generic "sum tile" shader until 1x1
  // You have a template for hierarchical reduction in reduction.frag.js
  // (its child-sum logic is a pattern to emulate for general grid sums)
  return readBack1x1()
```

- The hierarchical **reduction pattern** mirrors `reduction.frag.js` (but generalizes from fixed 2× downsample to arbitrary tile).
- For quick “is it sane?” checks: `sum(rho)` equals total mass; `sum(phi)` ~ arbitrary but DC=0 after Poisson; `sumSq` invariance under unitary iFFT (Parseval).

---

## 4) **Isolated pipelines** per stage (no dependencies)

Each isolated test binds its own inputs (from generators or snapshots), runs exactly one group of passes, and dumps observables.

### 4.1 Mass deposition isolation (L0 only)

```
function isoDeposit(ps):
  beginIsolation('deposit')
  clear(L0); clear(RHO_REAL)
  // Reuse aggregation.vert.js + aggregation.frag.js to write ∑(m·x,y,z), ∑m to L0
  runProgram(programs.aggregation, { u_positions, u_worldMin/Max, grid uniforms })
  copy L0.A → RHO_REAL                           // simple copy pass (fullscreen)
  view3DField(RHO_REAL,'real','scalar',slice)
  assertNear(reduceScalar(RHO_REAL,'sum'), totalMassFromPositions)
  endIsolation()
```

- Uses the existing aggregation vertex/frag exactly; only adds **copy mass** step.

### 4.2 FFT isolation

```
function isoFFT(ps, sourceSlot: DebugSlot):
  beginIsolation('fft')
  assert(sourceSlot in {RHO_REAL, AX, ...})
  fftForward3D(sourceSlot → RHO_K)
  fftInverse3D(RHO_K → tmpReal)
  rmse = compareRMSE(tmpReal, sourceSlot)
  log('FFT round-trip RMSE', rmse)
  // Parseval check:
  E_spatial = reduceScalar(sourceSlot,'sumSq')
  E_freq    = reduceScalar(RHO_K,'sumSq') / (NxNyNz)    // depending on normalization
  endIsolation()
```

- Reuse fullscreen quad; 1D Stockham stages along X/Y/Z respect the slicing.

### 4.3 Poisson‑in‑k isolation

```
function isoPoisson(ps):
  beginIsolation('poisson')
  // Inputs: RHO_K (from isoFFT or generator via FFT)
  solvePoissonInK(RHO_K → PHI_K)          // φ̂ = -4πG ρ̂ / |k|², φ̂(0)=0
  computeAccelerationK(PHI_K → GKX,GKY,GKZ)   // ĝ = i k φ̂
  // Consistency: k·ĝ ?= -4πG ρ̂
  divG = dot(i*k, ĝ)                      // compute in shader, compare to -4πG ρ̂
  err = reduceScalar(|divG + 4πG * RHO_K|,'sum')
  log('Poisson divergence residual', err)
  endIsolation()
```

### 4.4 iFFT→acceleration field isolation

```
function isoIFFTAccel(ps):
  beginIsolation('ifft-accel')
  fftInverse3D(GKX → AX); fftInverse3D(GKY → AY); fftInverse3D(GKZ → AZ)
  // Visual: show slices of AX/AY/AZ
  view3DField(AX,'real','x',slice)
  endIsolation()
```

### 4.5 PM sampling isolation

```
function isoSamplePM(ps):
  beginIsolation('samplePM')
  // bind POSITIONS (from lattice or snapshot) and AX/AY/AZ
  clear(FORCE)
  runProgram(programs.samplePM, { u_positions, AX, AY, AZ } → FORCE)
  // Spot-check a few known points with probeAt(AX/AY/AZ) vs analytic model
  endIsolation()
```

- Sampling uses the same **voxel↔texel** mapping and trilinear gather logic you already use conceptually in traversal; port those helpers.

### 4.6 Near‑field correction isolation

```
function isoNearField(ps):
  beginIsolation('near-field')
  // Inputs: L0 (∑(m·x,y,z), ∑m), POSITIONS
  clear(FORCE)
  runProgram(programs.nearField, { u_positions, L0, r_cut|sigma, softening } → FORCE)
  // Optional: inplace correctness vs tiny O(N^2) direct-sum for ~512 particles:
  runProgram(programs.directSumTiny, { u_positionsSubset } → FORCE_GT)
  rmse = compareRMSE(FORCE[subset], FORCE_GT)
  endIsolation()
```

- Near‑field kernel reuses the **L0 neighborhood loop** idea from `traversal.frag.js` (replace Newtonian kernel with the short‑range split kernel).

---

## 5) Wiring into `ParticleSystem` (no risk to main loop)

Add **debug modes** and **step hooks** without touching the main code paths.

**Signatures**

```
enum StepMode { NORMAL_BH, PM, ISO_DEPOSIT, ISO_FFT, ISO_POISSON, ISO_IFFT, ISO_SAMPLE_PM, ISO_NEAR_FIELD }

class ParticleSystem {
  setStepMode(mode: StepMode): void
  step(): void                     // existing
  stepIsolatedOnce(): void         // run one isolated pass (non-realtime)
}
```

**Pseudocode**

```
setStepMode(mode):
  this.stepMode = mode

step():
  if (!isInitialized) return
  if (profiler) profiler.update()
  switch (stepMode):
    case NORMAL_BH:
      buildQuadtree(); clearForceTexture();
      pipelineCalculateForces(this); pipelineIntegratePhysics(this)
      break
    case PM:
      stepPM(this)    // from previous plan (PM pipeline)
      break
    default:
      stepIsolatedOnce()

stepIsolatedOnce():
  switch (stepMode):
    case ISO_DEPOSIT:   isoDeposit(this); break
    case ISO_FFT:       isoFFT(this, RHO_REAL); break
    case ISO_POISSON:   isoPoisson(this); break
    case ISO_IFFT:      isoIFFTAccel(this); break
    case ISO_SAMPLE_PM: isoSamplePM(this); break
    case ISO_NEAR_FIELD:isoNearField(this); break
```

- Leverage existing **debug helpers** (`unbindAllTextures`, `checkGl`, `checkFBO`) before and after each isolated pass.
- Reuse **profiler** labels: `profiler.begin('iso_fftX') / end()`.

---

## 6) Contracts & invariants to assert per stage

- **Deposit**: `sum(RHO_REAL) == total mass` (allow ~1e‑5 rel. error).
- **FFT/iFFT roundtrip**: `RMSE(tmpReal, RHO_REAL) < ε_fft` (tune by grid size).
- **Poisson**: Enforce `φ̂(0)=0`. Check `||k·ĝ + 4πG ρ̂||_2` small.
- **iFFT accel**: For a **delta mass at center**, radial average of |g(r)| ~ `G m / r^2` outside a few cells.
- **Sampling**: `FORCE` at lattice points ≈ grid accel at those voxels (within trilinear error).
- **Near‑field**: For small (N) subset, RMSE(FORCE, direct‑sum) small inside `r < r_cut`.

---

## 7) Minimal shader/test plumbing you already have

- **Fullscreen quad** and pass scaffolding → reuse verbatim.
- **Aggregation to L0** (positions→L0 mass & COM numerators) → reuse in deposit isolation.
- **Hierarchical reduction pattern** → adapt `reduction.frag.js` design for generic “sum tiles” in observers.
- **L0 neighborhood loops** → reuse for standalone near‑field correction.
- **Integrator** → can be bypassed or used to “freeze” positions (don’t call it in isolated modes).

---

## 8) Example debugging flows

### A) “FFT only” bring‑up

```
setStepMode(ISO_DEPOSIT)
genRhoDelta(center, mass=1)
isoDeposit()              // produces RHO_REAL
isoFFT(RHO_REAL)          // checks roundtrip + Parseval
view3DField(RHO_K,'magnitude',slice)
```

### B) Poisson/grad sanity

```
setStepMode(ISO_POISSON)
fftForward3D(RHO_REAL→RHO_K)
isoPoisson()              // writes PHI_K, GKX/GKY/GKZ and divergence residual
```

### C) End‑to‑end PM without particles

```
genRhoGaussian(center, sigma=1.5, mass=1)
fftForward3D → solvePoissonInK → gradK → iFFT → AX/AY/AZ
view3DField(AX,'real','x',slice)
```

### D) Near‑field correctness (micro case)

```
genPositionsLattice(step=(8,8,8)) and assign small masses
copy L0.A → RHO_REAL
isoNearField() and compare vs directSumTiny()
```

---

## 9) Deliverables (what to add)

- `DebugUnloader` (resource router + isolation harness).
- Generators: `genRhoDelta`, `genRhoGaussian`, `genRhoPlaneWave`, `genPositionsLattice`.
- Observers: `view3DField`, `reduceScalar`, `compareRMSE`, `probeAt`.
- Isolated runners: `isoDeposit`, `isoFFT`, `isoPoisson`, `isoIFFTAccel`, `isoSamplePM`, `isoNearField`.
- `ParticleSystem.setStepMode`, `stepIsolatedOnce` switchboard.

---

### Why this works well with the code

- It **reuses the 3D‑in‑2D** mapping and shader scaffolding, so all isolated passes “think” they’re inside the full system.
- The **profiler and debug helpers** wrap every isolated pass so GL state and FBO completeness are checked systematically.
- You can toggle between **BH**, **PM**, and **isolated** within the existing `step()` loop without touching integration or rendering code.
