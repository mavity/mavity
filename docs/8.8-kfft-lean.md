# KFFT Lean Architecture

**Scope:** This optimization applies only to `particle-system/gravity-spectral-kernels/k-fft.js`. The mesh system's FFT implementation (`particle-system/gravity-mesh-kernels/k-fft.js`) is separate and unaffected.

## Current State

KFFT uses 6+ textures per instance:
- `inReal` - R32F input for forward FFT
- `inComplex` - RG32F input for inverse FFT  
- `outReal` - R32F output for inverse FFT
- `outComplex` - RG32F output for forward FFT
- `workingTexture` - RG32F ping-pong buffer
- `pingPongTexture` - RG32F ping-pong buffer

Plus 2 extra shader programs for real↔complex conversion.

The spectral system creates 4 KFFT instances (1 forward + 3 inverse), wasting significant memory.

## Proposed Architecture

### Textures

KFFT has exactly 3 textures:
- `real` - R32F texture (single-channel real values)
- `complexFrom` - RG32F ping-pong buffer (input/working buffer)
- `complexTo` - RG32F ping-pong buffer (output/working buffer)

**Texture swapping invariant:** During ping-pong execution, `complexFrom` and `complexTo` constantly swap roles. When KFFT is at rest (between `run()` calls), the variables maintain their semantic meaning:
- `complexFrom` always contains input/result data
- `complexTo` may contain intermediate or stale data (especially after inverse FFT)

### Shader Strategy

**Three shader program variants** generated from a single shader source function:
- `fftProgram({ collapsed: 'from' })` - First stage of forward FFT: reads R32F `real` texture, assumes imaginary=0, writes RG32F
- `fftProgram({ collapsed: 'to' })` - Final stage of inverse FFT: reads RG32F, writes R32F `real` texture with 1/N³ normalization
- `fftProgram()` - All other stages: reads RG32F, writes RG32F

The shader source `fft.frag.js` becomes a **generator function** taking `collapsed` parameter ('from' | 'to' | default). The knowledge of the parameter is **baked into shader text**, not passed as a uniform.

### FFT Operations

#### Forward FFT
  - external **real → complexTo**
  - ping-pongs **complexFrom → complexTo**
  - result in **complexTo**

#### Inverse FFT:
  - external **complexFrom**
  - ping-pongs **complexFrom → complexTo**
  - final **complexFrom → real**
  - result in **real**

### Memory Savings

**Current:** 4 KFFT instances × 6 textures = 24 texture objects

**Proposed:** 1 KFFT instance × 3 textures = 3 texture objects

**Savings:** 21 texture objects eliminated

Plus elimination of 8 shader programs (4 instances × 2 conversion programs = 8, replaced by 3 total programs).

## Implementation

1. Convert `fft.frag.js` to a function taking `collapsed` parameter ('from' | 'to' | null)
2. Restructure KFFT constructor to compile 3 shader variants: `fftProgramRealToComplex`, `fftProgramComplexToReal`, `fftProgramComplexToComplex`
3. Replace 6 textures with 3: `real`, `complexFrom`, `complexTo`
4. Update `_perform3DFFT` to:
   - Select `fftProgramRealToComplex` for first stage of forward FFT
   - Select `fftProgramComplexToReal` for final stage of inverse FFT
   - Select `fftProgramComplexToComplex` for all other stages
   - Maintain swap invariant: complexFrom or real is source, complexTo or real is destination, respective by inverse flag
5. Remove `realToComplexProgram` and `complexToRealProgram` (replaced by shader variants)
6. Update `particle-system-spectral-kernels.js` to use single shared KFFT instance:
   - Remove `fftInverseX`, `fftInverseY`, `fftInverseZ` instances
   - Set kfft.inverse=false and call `fftForwardKernel.run()` for forward transform
   - Set kfft.inverse=true and call `fftForwardKernel.run()` three times for inverse transforms
