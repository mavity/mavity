# Quadrupole Traversal Instability — Phase 1 (Parent‑Anchored Refinement)

This note documents the failure mode we’re seeing in sparse/adversarial layouts, the current traversal behavior causing it, and a concrete, bounded fix that restores correctness without reverting to full-grid scans at all levels.

**NOTE:** This relates explicitly to [Kernels-based Quadrupole particle system](../particle-system/gravity-multipole/particle-system-quadrupole-kernels.js) only. Other implementations are not in scope.

## Context and symptoms

- Failing tests (2‑body and convergence): force field is identically zero; particles don’t move.
- Diagnostics show:
  - A0 (monopole) populated at every level: exactly two non‑zero voxels per level; masses consistent.
  - A1/A2 quadrupole layers are zero (expected for minimal setups; monopole alone should still move particles).
  - Traversal force texture is all zeros in the 2‑body case → contributions dropped.
- θ sweep on a larger layout: internal velocity distributions widen for smaller θ (as expected), but the aggregate metric used by the test didn’t move enough to pass.

Conclusion: the pyramid build is fine; traversal coverage is brittle and can miss required cells.

## Root cause (code‑level)

Current refinement is anchored to the particle’s voxel at each finer level, not to the parent cell that failed the MAC.

- At the coarsest level (e.g., 8³): full scan of all cells.
- For finer levels: the code computes a particle‑centered neighborhood with radius `nb = ceil(1/θ)` and scans only that window.
- If a parent cell fails MAC at level L (and is not the home cell), we “continue” and implicitly hope the next level’s particle‑centered window will include all of that parent’s children. That’s not guaranteed.
- Result: the sibling child voxel containing the other particle can be outside the particle‑centered window at L‑1, so it’s never visited at any level → contribution lost → zero force.

This explains the 2‑body zero‑force failure despite A0 being correct at all levels.

## Current shader behavior (summary)

 In [k-traversal-quadrupole.js](../particle-system/gravity-multipole/k-traversal-quadrupole.js) → `buildTraversalQuadrupoleShader()`:

- Loops from coarsest level down to finest.
- Coarsest: scans the entire grid.
- Finer levels: window is particle‑voxel ± `nb`, where `nb = ceil(1/θ)`.
- For each candidate cell:
  - Skip empty cells; skip the home voxel at that level.
  - Compute MAC: `farEnough = (cellSize / (dist + eps)) < θ`.
    - If `farEnough`: accumulate and don’t refine further for that cell.
    - If not `farEnough` and not at finest level: `continue` (defer to next level, but without recording which parent failed).
    - If at the finest level: accept anyway to avoid dropping near‑field.

The missing piece: there’s no parent‑anchored descent over the actual children of failing parents.

## Phase 1 fix: parent‑anchored nested refinement (single‑pass)

Replace the particle‑centered scanning at finer levels with an explicit, bounded descent from each failing parent cell into its 2×2×2 children at the next level. Keep full scan only at the coarsest level.

- Coarsest level Lc (e.g., 8³): iterate all voxels `v_c`.
  - If voxel empty → skip.
  - If MAC passes and voxel != home → accumulate contribution; do not descend.
  - Otherwise (MAC fails or voxel == home) → descend into the exact 8 children at level `Lc-1`:
    - Children index mapping: `child = v_c * 2 + {0,1}` per axis, clamp to grid.
- Level Lc-1: for each child `v_{c-1}` produced by Lc:
  - Same decision: if MAC passes and not home → accumulate; else descend to its 8 children at `Lc-2`.
- Repeat until the finest level L0.
  - At L0: accept all non‑empty non‑home voxels regardless of MAC to avoid dropping near field.

Properties:
- Correctness: Every failing parent’s children are visited. Siblings containing nearby mass cannot be missed.
- Performance: Coarsest level is still a full scan (small). Most cells pass MAC at coarse levels and don’t descend. Worst case degenerates to a full scan at all levels (same as today’s worst when θ is tiny), but practical cases prune heavily.

### Minimal implementation sketch (GLSL, conceptual)

The actual code will use nested loops with computed child index ranges rather than a dynamic worklist (WebGL2 limitation):

- Level 3 (coarsest, 8³): `for vx3, vy3, vz3` over all cells…
  - Decide PASS vs REFINE.
  - If REFINE → loop `ox, oy, oz ∈ {0,1}` to form children at Level 2.
- Level 2 (16³): for each produced child at L2… decide PASS vs REFINE; if REFINE → enumerate 8 children at L1.
- Level 1 (32³): same pattern down to L0.
- Level 0 (64³): accept non‑empty non‑home unconditionally.

Key math pieces provided by current shader remain valid:
- `voxelToTexel()` mapping per level using `u_gridSizes[level]` and `u_slicesPerRow[level]`.
- `sampleLevelA0/A1/A2()` helpers.
- Bounds, `cellSize`, `eps`, MAC, and force calculations unchanged.

### Home‑voxel treatment

- Keep “skip home voxel” at all levels to avoid self‑force.
- At finest level, still skip home voxel but accept all other non‑empty voxels even if MAC fails.

### Quadrupole terms

- Continue to add quadrupole force for `level > 0` where moments exist.
- In current tests, A1/A2 are zero; monopole path must be correct regardless.

## Test plan

- Re‑run the failing tests:
  - 2‑body: expect non‑zero forces and displacement > 0.
  - Smaller timestep improves accuracy: expect pass.
  - θ parameter controls approximation quality: expect stronger separation in the metric for θ ∈ {0.9, 0.5, 0.2}.
- Add micro‑scenarios (via REPL snippets) to confirm coverage:
  - Two particles in neighboring child voxels of the same failing coarse parent.
  - Two particles in diagonal children (maximally separated within parent) — still must be visited.
  - Particles in different coarse parents where one passes MAC (accumulate at coarse) and the other fails (descend) — mixed path sanity check.

## Performance considerations

- Coarsest full scan retained (8³ = 512 cells): cheap.
- Early pruning: most cells pass MAC at coarse levels; only a minority descends.
- Worst case (very small θ or clustered mass): approaches scanning all children across levels — same asymptotic worst case as the naive approach, but rarely realized in practice.
- Future optimization (Phase 2): hybrid refinement mask to avoid nested loops over empty children when many parents fail. This would require extra passes and a small mask buffer.

## Rollout scaffolding

- Introduce a compile‑time or uniform switch (e.g., `u_refineMode`):
  - `0` = current particle‑centered neighbor window (for A/B).
  - `1` = parent‑anchored nested refinement (default after validation).
- Keep all diagnostics in place (layer readers, force texture summaries) to capture regression quickly.

## Acceptance criteria

- 2‑body test: non‑zero total force and measurable displacement after one integration step.
- Convergence test: smaller timestep produces closer final positions (stronger pass signal than current).
- θ test: the chosen metric shows a monotonic or at least clear difference across θ values; internal stats already show widening distributions at smaller θ.
- No material performance regression on the main demos at default θ (within ±10% frame time), measured via REPL timing snapshots.

## Known risks and mitigations

- Shader size and loop nesting: 3 nested child enumerations (from L3→L2→L1→L0) are manageable and compile on WebGL2.
- Over‑refinement with very small θ: documented; acceptable for correctness. Users can raise θ.
- Self‑voxel special case: explicitly skipped at all levels; verified by tests.

---

Prepared: Phase 1 plan to restore correctness by removing the refinement coverage gap while keeping performance bounded by MAC pruning. Phase 2 can introduce refinement masks or localized parent lists if needed for heavy clustering scenarios.

## References (code & evidence)

Below are targeted, relative links into the repository for the specialist team. Each line includes a short pointer (search term or function name) to speed inspection.

- Traversal kernel (primary): [particle-system/gravity-multipole/k-traversal-quadrupole.js](../particle-system/gravity-multipole/k-traversal-quadrupole.js)
  - Key function: `buildTraversalQuadrupoleShader()` — search for the GLSL snippet that computes `nb = int(ceil(1.0 / u_theta))` and the nested loops that compute `startX/startY/startZ`.
  - Look for the lines that: `// Skip if this is my own voxel` and `if (!farEnough && !isFinestLevel) { continue; }` — these embody the coverage gap.

- Kernel orchestration / wiring: [particle-system/gravity-multipole/particle-system-quadrupole-kernels.js](../particle-system/gravity-multipole/particle-system-quadrupole-kernels.js)
  - Methods: `_buildOctree()` and `_calculateForces()` — verify how texture arrays are copied into `levelTextureArrayA0/A1/A2` and how the traversal kernel is wired and run.
  - Copy helper: `_copyToArrayLayer(layer, kernel)` uses `copyTexSubImage3D` and `gl.readBuffer` — search for `copyTexSubImage3D` to review copy correctness and per-layer sizes.

- Aggregator (L0) kernel: [particle-system/gravity-multipole/k-aggregator-quadrupole.js](../particle-system/gravity-multipole/k-aggregator-quadrupole.js)
  - Verifies A0/A1/A2 MRT outputs and produces occupancy. Search for `outA0`, `outA1`, `outA2`, and `outOccupancy`.

- Pyramid build kernels: [particle-system/gravity-multipole/k-pyramid-build.js](../particle-system/gravity-multipole/k-pyramid-build.js)
  - Responsible for reducing L -> L+1. Inspect `run()` and attachments to ensure per-level outputs are correct.

- Convergence / regression tests: [particle-system/gravity-multipole/quadrupole-kernels.convergence.test.js](../particle-system/gravity-multipole/quadrupole-kernels.convergence.test.js)
  - Failing assertions referenced in REPL session. Search the test for the assertions "Simulation not working: particle did not move" and "Theta should affect results" to locate exact checks.

- REPL session (test evidence and diagnostic dumps): [daebug/12-iris-2105-47.md](12-iris-2105-47.md)
  - This file contains the failing run output. Relevant excerpts to inspect:
    - Test summary: `Test Results: 1 pass, 3 fail` near the top of the file.
    - The two‑particle diagnostics showing A0 populated and A1/A2 empty: search for the block starting with `Aggregator:` and the `A0 (monopole):` section.
    - The traversal diagnostic lines: search for `KTraversalQuadrupole` (it prints `theta=...` and `force: totalForceMag=0`).
    - The failing test traces: look for the assertion messages `Simulation not working: particle did not move` and `Physics not working.` which show the captured kernel dumps.

- Diagnostic helpers and readers: [particle-system/diag.js](../particle-system/diag.js)
  - Functions like `readLinear()` and `formatNumber` are used to dump textures; review them to understand how the tests compute statistics.

### Quick grep/search keywords

If you want to jump directly, use these search terms in the codebase (they appear verbatim):

- `int(ceil(1.0 / u_theta))`
- `// Skip if this is my own voxel`
- `if (!farEnough && !isFinestLevel) {` 
- `copyTexSubImage3D`
- `KTraversalQuadrupole(`
- `A0 (monopole):`
- `totalForceMag=0`

## Evidence pointers (what to validate first)

1. Confirm A0 is populated while A1/A2 are empty (implies pyramid build succeeded, but quadrupole moments are zero): open `daebug/12-iris-2105-47.md` and find the `A0 (monopole):` and `A1 (quadrupole ...)` blocks. The two‑particle run shows non‑zero A0 entries across layers and zeros for A1/A2.

2. Confirm traversal produced zero force for the 2‑particle case: in `daebug/12-iris-2105-47.md` search for `KTraversalQuadrupole(` followed by the `force:` section; it should read `totalForceMag=0` and all fx/fy/fz entries zero.

3. Reproduce the MAC gap locally by instrumenting the traversal shader (or using the REPL) to dump `level`, `testVoxel` and `farEnough` decisions for one particle; a quick approach is to add a debug path that writes a small per‑particle mask of visited voxels (or counts) into `outForce.w` temporarily.

4. Measure behavior under the θ sweep in `daebug/12-iris-2105-47.md`: locate the `--- [0] Theta = 0.9 ---` etc. sections — they contain early/mid/final snapshots and velocity std differences that show θ has some effect in denser scenes.

## Suggested checklist for the specialist team

1. Open `particle-system/gravity-multipole/k-traversal-quadrupole.js` and search for the exact lines noted above; confirm the particle‑centered `nb` window + `continue` on MAC fail.
2. Run the two‑particle convergence test in REPL (`daebug/12-iris-2105-47.md` contains the run command used). Reproduce and capture a fresh diagnostic dump.
3. Apply the Phase 1 change (parent‑anchored nested refinement) in a branch and re-run the failing tests. Compare diagnostics to confirm A0 contributions are now counted in traversal.
4. If Phase 1 regresses performance on real demos, consider Phase 2 (refinement mask) which trades a small number of extra passes for more selective refinement.

---

## Correct Algorithm Specification (Geometric, Stateless)

After analysis and discussion, the correct Barnes-Hut traversal algorithm should be purely geometric and stateless. Each voxel's treatment is determined solely by its spatial relationship to the particle and the theta parameter.

### Core Principle

For each voxel at each level, compute three distances:
- **Distance to voxel center** (`distCenter`)
- **Distance to nearest point on voxel** (`distNear`)
- **Distance to farthest point on voxel** (`distFar`)

Then apply these rules:

1. **If `distFar * theta < cellSize`**: Entire voxel is far enough
   - Use full voxel mass/moments for force calculation
   - Do not examine children at finer levels

2. **If `distNear * theta >= cellSize`**: Entire voxel is too close
   - Skip this voxel entirely at this level
   - Children will be handled at finer level

3. **If `distNear * theta < cellSize <= distFar * theta`**: Voxel straddles acceptance boundary
   - Compute **residual mass** = voxel mass - sum(children masses)
   - Use residual for force calculation
   - Children will contribute their mass at finer level

### Optimization: Geometric Loop Bounds

At each level, we only need to scan a geometric shell/annulus of voxels:

- **Inner radius** (`r_inner`): Voxels closer than this are handled at finer levels
  - `r_inner = theta * cellSize`
  
- **Outer radius** (`r_outer`): Voxels farther than this were already handled at coarser level
  - `r_outer = theta * cellSize_coarser`

Convert to voxel index bounds:
```glsl
int minIdx = floor((r_inner - cellSize) / cellSize);  // -cellSize for voxel extent
int maxIdx = ceil((r_outer + cellSize) / cellSize);   // +cellSize for voxel extent

// Clamp to grid and offset by particle voxel
int startX = max(0, myVoxel.x + minIdx);
int endX = min(gridSize - 1, myVoxel.x + maxIdx);
// Similar for Y and Z
```

### Benefits

1. **Correctness**: No coverage gaps - every bit of mass contributes exactly once
2. **Performance**: Only scan the refinement frontier (thin shell), not entire grids
3. **Simplicity**: No state tracking, no parent acceptance masks, purely geometric
4. **WebGL2-friendly**: Fixed loop bounds computable per-level, no dynamic branching on history

### Implementation Notes

- **Residual computation** requires fetching all 8 children of a parent voxel
- Children at level L are at positions `parent*2 + {0,1}` per axis in level L-1 grid
- Use existing `voxelToTexel()` and `sampleLevelA0/A1/A2()` helpers
- At finest level (L0), accept all non-home voxels regardless (no finer level exists)

---

If you want, I can now implement this corrected algorithm in the traversal shader and produce a branch/PR with the update and validation tests. 
