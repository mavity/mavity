# World Bounds Management (8.7)

**Status:** Planning document for future implementation  
**Scope:** Dynamic world bounds detection and adaptive grid recalibration across all particle systems  
**Priority:** Medium (improves robustness for open-ended simulations)

---

## 1. Problem Description

### Current State

All kernel-based particle systems use **static world bounds** set at construction time:

- **Spectral/Mesh methods (PM/FFT):** Bounds determine grid resolution and cell-to-particle mapping. Changing bounds invalidates grid coordinates.
- **Quadrupole/Multipole (octree):** Bounds determine Morton code encoding. Changing bounds invalidates tree indexing.
- **Monopole:** Uses dynamic bounds via CPU readback, but introduces pipeline stalls.

### Issues

1. **Particle escape:** If particles move beyond world bounds, they cause numerical errors:
   - Spectral/mesh: grid coordinates become invalid (negative or >gridSize)
   - Quadrupole: Morton codes map to wrong cells
   - Forces computed at escape coordinates are meaningless

2. **User friction:** Bounds must be manually tuned at init time, with safety margins added by hand.

3. **Dynamic phenomena:** Expanding particle clouds, ejected streams, or growing simulations require bounds adjustment or simulation restart.

4. **Monopole readback overhead:** `updateWorldBoundsFromTexture()` uses `gl.readPixels()` every 10 seconds, causing CPU-GPU sync stalls (~1-5ms).

---

## 2. Bounce Solution (Enabled by Default)

### Rationale

The simplest, lowest-cost solution for most demos and contained systems.

### Implementation

Add optional elastic bounce to particle integration kernels (`KIntegratePosition`, `KIntegrateVelocity`).

**When enabled:**
- Particles reflect off world bound planes with velocity reversal
- Optionally apply damping coefficient (e.g., `vel *= 0.95` on bounce)
- No grid restructuring or bounds recalculation needed
- Bounds remain static by design

**Shader pseudocode:**
```glsl
vec3 newPos = pos + vel * dt;

// Bounce off min boundary
if (newPos.x < u_worldMin.x) {
  newPos.x = u_worldMin.x + (u_worldMin.x - newPos.x) * 0.95;  // reflect
  vel.x = -vel.x * 0.95;  // reverse + damp
}

// Bounce off max boundary
if (newPos.x > u_worldMax.x) {
  newPos.x = u_worldMax.x - (newPos.x - u_worldMax.x) * 0.95;  // reflect
  vel.x = -vel.x * 0.95;
}

// Same for y, z
// ...
```

**Pros:**
- Zero additional compute (done during standard integration)
- No grid/pyramid rebuilds
- Prevents escape artifacts entirely
- Familiar physics to users (billiard-ball model)

**Cons:**
- Changes simulation semantics (not pure gravity)
- May introduce clustering near boundaries
- Not suitable for truly open-ended simulations (e.g., solar system)

**Default behavior:** Bounce enabled with no dampening, but could later introduce `bounceDamping = 0.95` (elastic with slight energy loss).

---

## 3. Regular On-GPU Recalculation

### Overview

For simulations that need truly dynamic bounds (expanding clouds, ejected particles), implement asynchronous GPU-based bounds detection that runs every N frames without CPU readback stalls.

**Key principle:** Use hierarchical reduction on GPU, similar to `KPyramidBuild`, to find global min/max in log(N) passes. Results stay in GPU memory.

---

### 3.1 Core Algorithm: GPU Bounds Reduction Kernel

#### Concept: Multi-Stage Pyramid Reduction

**Stage 0 (Particle → Tile blocks):**
- Deposit particles into coarse tiles (e.g., 8×8×8)
- Each tile computes local min/max of its particles
- Output: small texture with per-tile bounds

**Stage 1 to N (Hierarchical reduction):**
- Apply 2×2×2 reduction: combine 8 child tiles into 1 parent tile
- Each output tile = min/max of 8 input tiles
- Repeat until 1×1 result

**Final output:** 1×1 or 2×1 texture containing global bounds:
```glsl
// boundsMinTexture[0] = (minX, minY, minZ, pad)
// boundsMaxTexture[0] = (maxX, maxY, maxZ, pad)
```

#### Shader Design: KComputeBounds

**Vertex stage:** Render full-screen quad (like `KPyramidBuild`).

**Fragment stage:**
```glsl
#version 300 es
precision highp float;

// Input: particle texture
uniform sampler2D u_particleData;
uniform vec2 u_particleTexSize;
uniform int u_stage;  // 0 = tile reduction, >0 = pyramid reduction

// Stage-dependent sampling offsets
// Stage 0: sample N particles from a tile block
// Stage N>0: sample 8 neighbors (like pyramid reduce)

out vec4 outMinBounds;  // (minX, minY, minZ, count)
out vec4 outMaxBounds;  // (maxX, maxY, maxZ, pad)

void main() {
  vec3 localMin = vec3(1e9);
  vec3 localMax = vec3(-1e9);
  int activeCount = 0;
  
  // Sample particles/parent tiles in this region
  for (int i = 0; i < SAMPLE_COUNT; i++) {
    vec4 particle = texture(u_particleData, sampleCoord[i]);
    float mass = particle.w;
    
    if (mass > 0.0) {  // Only active particles
      vec3 pos = particle.xyz;
      localMin = min(localMin, pos);
      localMax = max(localMax, pos);
      activeCount++;
    }
  }
  
  outMinBounds = vec4(localMin, float(activeCount));
  outMaxBounds = vec4(localMax, 0.0);
}
```

#### Handy Dual-Use: Collect Additional Stats

Since we're already running a reduction pass, compute useful statistics for free:

**Secondary outputs** (packed in unused channels or separate textures):

```glsl
out vec4 outStats;  // (particleCount, centerX, centerY, centerZ)
out vec4 outSecondaryStats;  // (velMin, velMax, meanMass, maxMass)
```

**Potential metrics:**
- **Particle count** (per tile, or cumulative)
- **Center of mass** (sum of weighted positions / total mass)
- **Velocity bounds** (minV, maxV magnitudes)
- **Mass statistics** (mean mass, max mass, total mass)
- **Density distribution** (occupy ratio per tile)

**Use cases:**
- Auto-adjust damping or gravity based on density
- Detect empty regions and skip empty tiles in subsequent computations
- Estimate simulation "health" (e.g., warn if particles ejected too far)
- Render heatmaps of activity density

---

### 3.2 Per-Particle-System Details and Optimization

#### **Spectral Method (PM/FFT)**

**What changes when bounds update:**
- Grid cell size: `cellSize = worldSize / gridSize` (recompute for gradient/poisson kernels)
- Deposit shader: world-to-grid mapping `(worldPos - worldMin) / (worldMax - worldMin) * gridSize`
- Force-sample shader: same mapping (inverse)
- FFT plans: **unchanged** (FFT cares about array size `gridSize`, not physical extent)

**Work required:**
- Recompute `worldSize` vector (3 float math ops)
- Update uniforms in `KDeposit` and `KForceSample` (no shader recompile)
- Update uniforms in `KGradient` and `KPoisson` (no shader recompile)
- Clear mass grid to avoid stale deposits

**Optimization for sparse detection:**

Since spectral deposits particles to a 3D grid, most of the grid is empty. Only particles near the **boundary of the populated region** contribute to bounds changes:

**Approach: Boundary-layer tracking**
- Modify `KDeposit` to output a secondary "boundary cell" texture (only cells touching particles)
- After deposit, read back only the **maximal x/y/z indices** where deposits occurred
- These 6 values (min/max per axis) directly give bounds
- Skip full pyramid reduction if domain is small

**Cost:** 
- Normal case: ~1-2ms pyramid reduction (logarithmic passes)
- Optimized: ~0.1-0.3ms boundary read (only 6-12 texel fetches)

**Implementation detail:**
```glsl
// In KDeposit fragment, store boundary info
ivec3 gridCell = /* computed cell */
if (any(lessThan(gridCell, ivec3(1))) || any(greaterThanEqual(gridCell, ivec3(gridSize - 1)))) {
  outBoundaryFlag = 1.0;  // Mark as boundary cell
}
// Separate pass: scan for max boundary indices → bounds
```

---

#### **Mesh Method (PM/FFT with near-field)**

**Similar to Spectral, plus:**
- Near-field kernel (`KNearField`) also uses `worldBounds`
- Near-field radius is typically fixed, but could be percentage-based
- Update sequence: same as spectral

**Work required:** ~same as spectral (update 5-6 kernel uniforms)

**Boundary optimization:** Identical to spectral (boundary-layer tracking works here too)

---

#### **Quadrupole/Multipole (Octree with Morton encoding)**

**What changes when bounds update:**
- **Morton codes must be recomputed** for all particles
  ```js
  // Morton encodes position relative to world bounds
  // Old: morton(pos, oldBounds) → wrong cells
  // New: morton(pos, newBounds) → correct cells
  ```
- **Octree must be rebuilt** (pyramid build respects new morton codes automatically once they're updated)

**Work required:**
- Recompute Morton codes for all N particles (GPU compute or fragment shader pass)
- Clear all octree levels
- Rebuild pyramid (normal flow on next `step()`)

**Cost:** 
- 1 GPU pass to recompute Morton codes (~1-2ms for N particles)
- Next frame: normal octree rebuild (no extra cost, just uses new codes)

**Optimization for sparse detection:**

Octrees naturally partition particles by cell. Only cells **at the boundary of the occupied octree** affect bounds.

**Approach: Boundary octree cells tracking**
- During pyramid build, **flag cells as "boundary"** if they contain particles OR neighbor cells with particles
- After build, collect boundary cell coordinates
- Bounds = AABB of boundary cell positions

**Cost:**
- Flag pass during pyramid: minimal overhead (~0.1-0.2ms, already doing reduction)
- Collect boundary cells: ~0.5-1ms (read 6 texel values: min/max per level)
- Recompute Morton codes: only if bounds changes significantly

**Implementation detail:**
```glsl
// During KPyramidBuild, detect boundary cells
bool isBoundaryCell = any(lessThan(cellPos, ivec3(1))) || 
                      any(greaterThanEqual(cellPos, ivec3(gridSize - 1)));
// Also mark cells at level boundaries
if (level == numLevels - 1) isBoundaryCell = true;

// Separate pass: scan octree for boundary cell extents
// These directly give new bounds
```

---

#### **Monopole (Barnes-Hut with octree)**

**Current state:** Uses CPU readback via `updateWorldBoundsFromTexture()` every 10 seconds.

**Proposed change:** Replace with GPU reduction kernel

**What changes when bounds update:**
- Aggregation stage uses bounds for position encoding (like quadrupole)
- Traversal uses bounds for MAC distance calculations
- Similar to quadrupole in most respects

**Work required:**
- Replace `updateWorldBoundsFromTexture()` with asynchronous `KComputeBounds.run()`
- On detection of significant change (e.g., >5% shift), flag `needsAggregationRebuild`
- Next frame: skip aggregation caching, rebuild from particles

**Optimization:** Boundary tracking same as quadrupole (flag during aggregation pass)

---

### 3.3 Update Strategy and Hysteresis

To avoid thrashing due to noisy particle motion:

**Hysteresis thresholds:**
```js
const BOUNDS_UPDATE_INTERVAL = 60;  // Check every 60 frames (~1 sec at 60fps)
const BOUNDS_CHANGE_THRESHOLD = 0.10;  // 10% change triggers rebuild

function checkBoundsUpdate() {
  if (frameCount % BOUNDS_UPDATE_INTERVAL !== 0) return;
  
  const newBounds = computeBoundsKernel.run();
  const change = computeBoundsChange(newBounds, currentBounds);
  
  if (change > BOUNDS_CHANGE_THRESHOLD) {
    updateWorldBounds(newBounds);
  }
}

function computeBoundsChange(newB, oldB) {
  const oldSize = norm(oldB.max - oldB.min);
  const newSize = norm(newB.max - newB.min);
  const centerShift = norm(center(newB) - center(oldB));
  
  return Math.max(
    Math.abs(newSize - oldSize) / oldSize,
    centerShift / oldSize
  );
}
```

**Effect:**
- Bounds update only when significant change is detected
- Updates are infrequent (~every 1-2 seconds)
- No cascading rebuilds from small jitter
- Fully controllable via parameters

---

### 3.4 Scheduling and Integration

**Option A: Automatic (within `step()`)**
```js
step() {
  if (this.frameCount % 60 === 0 && this.enableDynamicBounds) {
    const newBounds = this.computeBoundsKernel.run();
    if (this._boundsChanged(newBounds)) {
      this.updateWorldBounds(newBounds);
    }
  }
  
  this._computeForces();
  this._integratePhysics();
  this.frameCount++;
}
```

**Option B: Manual (caller decides)**
```js
// In application code
if (shouldUpdateBounds) {
  const newBounds = particleSystem.detectBounds();
  particleSystem.updateWorldBounds(newBounds);
}

particleSystem.step();
```

**Option C: Event-driven**
```js
particleSystem.on('boundsChangeDetected', (newBounds) => {
  console.log('Bounds shifted:', newBounds);
  // User code can log, adjust rendering, etc.
});
```

---

## 4. Implementation Roadmap

### Phase 1: Bounce (Low-hanging fruit, immediate)
- [ ] Add `enableBounce` and `bounceDamping` options to all integration kernels
- [ ] Update `KIntegratePosition` and `KIntegrateVelocity` shaders
- [ ] Add REPL tests for bounce behavior
- [ ] Enable by default in demos

### Phase 2: GPU Bounds Compute Kernel (Medium, ~2-3 days)
- [ ] Create `KComputeBounds` class (mimic `KPyramidBuild` structure)
- [ ] Implement multi-stage reduction shader
- [ ] Add secondary stats collection (particle count, center of mass, etc.)
- [ ] Unit tests for reduction accuracy
- [ ] Benchmark: verify ~1-2ms cost

### Phase 3: Per-System Integration (Medium, ~2-3 days)
- [ ] Add `setWorldBounds()` method to all kernel classes
- [ ] Add `updateWorldBounds()` method to each particle system class
- [ ] Spectral: integrate `KComputeBounds`, update deposit/force-sample uniforms
- [ ] Mesh: same as spectral
- [ ] Quadrupole: handle Morton re-encoding
- [ ] Monopole: replace readback with GPU kernel

### Phase 4: Boundary Optimization (Advanced, ~3-4 days)
- [ ] Implement boundary-layer tracking in `KDeposit` and aggregation shaders
- [ ] Add boundary cell collection pass
- [ ] Profile: compare full reduction vs. boundary tracking
- [ ] Gate behind feature flag (optional optimization)

### Phase 5: Testing and Polish (1-2 days)
- [ ] Integration tests: bounds update with particles escaping
- [ ] Render tests: verify forces remain correct after bounds update
- [ ] REPL tests: manual verification of bounds changes
- [ ] Documentation: guide users on when to enable dynamic bounds

---

## 5. Configuration Examples

### Bouncing-only (Default)
```js
const system = new ParticleSystemSpectralKernels(gl, {
  particleData: data,
  worldBounds: { min: [-4, -4, -4], max: [4, 4, 4] },
  enableBounce: true,
  bounceDamping: 0.95
});
```

### Dynamic bounds with boundary tracking (Full optimization)
```js
const system = new ParticleSystemSpectralKernels(gl, {
  particleData: data,
  worldBounds: { min: [-4, -4, -4], max: [4, 4, 4] },
  enableBounce: false,
  dynamicBounds: {
    enabled: true,
    updateInterval: 60,  // frames
    changeThreshold: 0.10,  // 10%
    useOptimizedBoundaryTracking: true
  }
});
```

### Monopole: hybrid approach (bounce + occasional recalc)
```js
const system = new ParticleSystemMonopoleKernels(gl, {
  particleData: data,
  worldBounds: { min: [-4, -4, 0], max: [4, 4, 2] },
  enableBounce: true,
  bounceDamping: 0.98,
  dynamicBounds: {
    enabled: true,
    updateInterval: 300,  // 5 seconds (less frequent than spectral)
    changeThreshold: 0.15
  }
});
```

---

## 6. Performance Expectations

| Method | Cost | Frequency | Use Case |
|--------|------|-----------|----------|
| **Bounce** | ~0.01ms (in-shader) | Every frame | Contained demos, default |
| **GPU bounds reduction** | ~1-2ms | Every 60 frames | Dynamic simulations |
| **Boundary tracking** | ~0.2-0.5ms | Every 60 frames | Sparse particle systems |
| **CPU readback (current monopole)** | ~2-5ms | Every 10 sec | Legacy, avoid |

**Total overhead with both bounce + GPU recalc every 60 frames:** <0.2% (1-2ms / 60 frames × 16.7ms)

---

## 7. Future Extensions

### Adaptive Gravity
If bounds recalc also computes center of mass and particle count, adjust `gravityStrength` dynamically:
```js
if (newStats.particleCount < threshold) {
  options.gravityStrength *= 1.1;  // Strengthen for sparse systems
}
```

### Adaptive Damping
Detect ejection (particles at boundary with high velocity) and increase damping locally:
```js
if (particleVelocity > maxSpeed && nearBoundary) {
  localDamping = 0.9;  // Increased drag
}
```

### Collision Detection
If particles cluster near bounds, flag for specialized handling (wall forces, friction).

### Multi-Camera Rendering
Track bounds to auto-fit camera zoom and pan.

---

## 8. Notes for Future Implementer

- **Kernel contract:** Follow WebGL2 kernel pattern (constructor takes options, `run()` is frame-agnostic, `dispose()` cleans up).
- **Testing:** Use daebug REPL to verify bounds updates mid-simulation. Add particles escaping and watch bounds expand.
- **Optimization profiling:** Measure pyramid reduction pass cost vs. boundary tracking to determine when to switch strategies.
- **Shader debugging:** Use `outColor = vec4(minBounds, 1.0)` to visualize computed bounds in render output.
- **Backward compatibility:** Existing code should work unchanged. New features are opt-in via `enableBounce` and `dynamicBounds` options.

