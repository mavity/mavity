# Plan C: Quadrupoles + improved MAC (FMM‑lite)

Below is a **high‑level, implementation‑ready blueprint** for **Plan C** (“keep the existing multi‑level voxel pyramid, add Quadrupoles + improved MAC, and make the integrator symplectic (KDK)”), written to slot into your current pipeline and file structure. I’ll reference the exact files where each change lives so it’s obvious what to touch. I’ll assume **`EXT_float_blend` is available** and used for additive MRT blending throughout. 

See [in context of alternative plans](4-refactoring-options.md).

---

## A. Data model upgrades (what each level stores)

**Goal:** keep your current per‑level texture(s) that already store **∑(m·x,y,z)** and **∑m**, and **add second‑moment accumulators** so we can assemble a **quadrupole tensor** at traversal time.

### A1) Per‑voxel aggregated moments (MRT attachments)

For each level `Lk`, allocate **three** color attachments (all `RGBA32F`):

* **Attachment A0 (existing):**
  `A0 = [ Σ(m·x), Σ(m·y), Σ(m·z), Σ(m) ]`  → already produced by L0 aggregation and reduced upwards.   

* **Attachment A1 (new, “diag+xy”):**
  `A1 = [ Σ(m·x²), Σ(m·y²), Σ(m·z²), Σ(m·x·y) ]`

* **Attachment A2 (new, “xz+yz”):**
  `A2 = [ Σ(m·x·z), Σ(m·y·z), 0, 0 ]`

> Rationale: these **raw** second moments (about the world origin) let us derive **central** moments on the fly:
> `S = M2 − M0·(μ ⊗ μ)` with `μ = M1/M0`. Then get a **trace‑free quadrupole**: `Q = 3S − tr(S)·I`.

**Where to implement/allocate:**
Extend texture arrays & FBO setup so each level has **A0/A1/A2** bound and drawn to in aggregation & reduction passes (MRT). Update `createTextures()` to allocate three attachments per level and `createShaderPrograms()` to compile the extended MRT variants. 

---

## B. Aggregation & reduction (what each pass writes)

### B1) L0 aggregation (particles → voxels) with MRT

**Files touched:** `aggregation.vert.js`, `aggregation.frag.js`, aggregator pipeline utilities.

* **Vertex path:** keep mapping particle → voxel via your current normalization and slice math; additionally compute **A1/A2** varyings per particle from `pos` and `mass`. 
* **Fragment path:** change from single `out vec4` to **three outputs**: `outA0`, `outA1`, `outA2`, and enable **additive blending** on all three attachments (ONE,ONE) (we assume `EXT_float_blend`). 
* **Draw state:** set `gl.drawBuffers([ATT0, ATT1, ATT2])` for the L0 FBO before drawing the particles (done in your `aggregateL0(this)` plumbing). 

**Pseudocode signature & flow**

```
function aggregateL0_WithQuadrupoles(system):
  bindFBO(level=L0, attachments=[A0,A1,A2])
  enableAdditiveBlendingForFloat()
  useProgram(programs.aggregation_MRT)
  setUniforms(worldMin, worldMax, gridSize=64, slicesPerRow=8, ...)
  drawParticlesAsPoints()  // one point per particle
```

(Extends your existing `aggregateL0(this)`.) 

### B2) Pyramid reduction (8 children → 1 parent) with MRT

**Files touched:** `reduction.frag.js`, reduction pipeline utilities.

* Keep the current gather of the **eight child voxels**, but **sum for A0, A1, and A2 in one pass** (MRT). Your full‑screen quad program remains the same vertex; fragment samples eight positions from “previous level” and accumulates into three color outputs.  

**Pseudocode signature & flow**

```
function pyramidReduce_WithQuadrupoles(system, srcLevel, dstLevel):
  bindFBO(level=dstLevel, attachments=[A0,A1,A2])
  useProgram(programs.reduction_MRT)
  setUniforms(srcGridSize, srcSlicesPerRow, ...)
  drawFullscreenQuad()
```

(Extends your existing `pyramidReduce(this, level, level+1)` loop.) 

---

## C. Traversal changes (MAC + Quadrupole evaluation)

**Goal:** improve acceptance (**MAC**) and use **quadrupole** contribution when a node is accepted. Near‑field at L0 remains a direct sum over a small neighborhood.

**Files touched:** `traversal.frag.js` (core), plus the uniform plumbing for extra textures (A1, A2). 

### C1) Inputs (per level)

* For each level `k`, bind three textures: `Lk_A0`, `Lk_A1`, `Lk_A2`.
* Keep `u_cellSizes[k]`, `u_gridSizes[k]`, `u_slicesPerRow[k]`, `u_worldMin`, `u_worldMax`, `u_theta`, `u_softening`, `u_G` as you already do. 

### C2) Improved acceptance criterion (offset MAC)

Replace the classic `s/d < θ` with:

```
d  = |com - target|
s  = cellSize(level)
c  = cellCenter(level, voxel)   // from level + voxel index + world bounds
δ  = |com - c|
ACCEPT if d > s/θ + δ
```

* If **accepted**, use **monopole + quadrupole** for this cell and **do not** re‑count the same mass at finer levels (see loop control below).
* If **not accepted**, let finer levels contribute (or fall through to L0 direct sum).
  (You already compute com from `A0`; derive `c` with the same slice math used in `aggregation.vert.js` and `reduction.frag.js`.)   

### C3) Quadrupole assembly (per accepted node)

**Given:**
`M0 = A0.a`, `M1 = A0.rgb`,
`M2 = [[A1.x, A1.w, A2.x], [A1.w, A1.y, A2.y], [A2.x, A2.y, A1.z]]` (raw second moments ∑m·x_ix_j).

**Compute (about COM):**

```
μ = M1 / M0                       // center of mass
S = M2 - M0 * outer(μ, μ)         // central second moments
trS = trace(S)
Q = 3 * S - trS * I               // trace-free quadrupole tensor
```

**Apply to acceleration (pseudocode):**

```
r  = com - targetPos
r2 = dot(r, r) + eps^2            // reuse your softening scheme
invR = rsqrt(r2)
invR3 = invR^3
// Monopole:
a += G * M0 * r * invR3
// Quadrupole:
Qr    = Q * r
rQr   = dot(r, Qr)
invR5 = invR^5
invR7 = invR^7
a += G * ( Qr * invR5 - 2.5 * rQr * r * invR7 )
```

(Keep all math in `highp` like today.) 

### C4) Traversal loop structure (to avoid double counting)

* **Far‑field:** iterate **from the coarsest level down to level 1 only**. Evaluate neighbors and apply the **offset MAC**. Accepted cells contribute **once** at that level; cells that fail the MAC are left to be handled at finer levels.
* **Near‑field:** handle **level 0** in a **single dedicated block** (direct sum in a small 3D window), as you already do.
  This removes the current overlap where level‑0 contributions can be counted twice (in the general loop and in the L0 block). 

**Pseudocode skeleton**

```
function accumulateFarFieldForces(targetIndex):
  myPos = sampleParticlePos(targetIndex)
  a = (0,0,0)
  for level in [Lmax .. L1]:
    for neighborVoxel in neighborhood(level, R=1):
      nodeA0 = sampleA0(level, neighborVoxel)
      if nodeA0.mass == 0: continue
      com = nodeA0.sumPos / nodeA0.mass
      d = |com - myPos|
      s = cellSize(level)
      c = cellCenter(level, neighborVoxel)
      δ = |com - c|
      if d > s/theta + δ:
        nodeA1 = sampleA1(level, neighborVoxel)
        nodeA2 = sampleA2(level, neighborVoxel)
        AccumulateMonopoleAndQuadrupole(a, myPos, nodeA0, nodeA1, nodeA2)
      else:
        // not accepted here; rely on finer levels or L0 near-field
        continue
  return a

function accumulateNearFieldL0(targetIndex):
  // keep your L0 3D window, Manhattan cutoff, and softening
  // use direct sums from A0.com + mass only (no quad needed here)
```

(Adapts your current structure that loops levels and then has a special L0 block.) 

---

## D. Symplectic integrator (KDK) without extra force cost per frame

**Goal:** do **Kick‑Drift‑Kick** using the **previous** frame’s force for the first half‑kick and the **current** frame’s force for the second half‑kick. This keeps one force evaluation per frame (after the drift) and only changes the **order** of your existing passes.

**Files touched:** `particle-system.js` (scheduler), `vel_integrate.frag.js`, `pos_integrate.frag.js`.   

### D1) Persistent force textures

* Keep **two** force textures: `forcePrev`, `forceCurr`. Initialize `forcePrev` from a bootstrap force evaluation at t=0. (Your current single `forceTexture` structure can be extended by adding another render texture.) 

### D2) Step scheduling (host‑side)

Replace `step()` with a **KDK scheduler**:

```
function step_KDK():
  // 1) first half-kick using previous forces
  kick(dtScale = 0.5, forceTex = forcePrev)   // vel_integrate.frag
  // 2) drift positions
  drift(dt)                                   // pos_integrate.frag
  // 3) rebuild pyramid at new positions & compute current forces
  buildQuadtree_WithQuadrupoles()             // aggregation+reduction MRT
  clear(forceCurr)
  accumulateForces_WithQuadrupoles(forceCurr) // traversal.frag (new MAC & quad)
  // 4) second half-kick using current forces
  kick(dtScale = 0.5, forceTex = forceCurr)   // vel_integrate.frag
  // 5) rotate forces
  swap(forcePrev, forceCurr)
```

(Uses your existing integration shaders; just pass `u_dt * 0.5` for the two kicks and bind the appropriate force texture each time.)   

**Function signatures (host)**

```
ParticleSystem.prototype.step_KDK(): void
ParticleSystem.prototype.kick(dtScale: number, forceTex: WebGLTexture): void
ParticleSystem.prototype.drift(dt: number): void
ParticleSystem.prototype.buildQuadtree_WithQuadrupoles(): void
ParticleSystem.prototype.accumulateForces_WithQuadrupoles(outForceTex: WebGLTexture): void
```

(These extend/replace your current `step()`, `buildQuadtree()`, and traversal pipeline calls.) 

---

## E. Parameters, uniforms, and toggles

* **`theta`**: unchanged semantic, but re‑tune with the new MAC.
* **`macMode`**: fixed to **offset‑MAC** (`d > s/θ + δ`).
* **`enableQuadrupole`**: compile‑time or uniform toggle to fall back to pure monopole at accepted nodes (handy for A/B tests).
* **`softening`**: unchanged; apply to both near‑ and far‑field denominators as you currently do. 

---

## F. Debug & validation hooks (recommended)

* **Forward–reverse test (time‑reversibility):** add a debug path that negates velocities, runs KDK for `N` steps, negates again, runs back `N` steps; measure positional mismatch. (No shader changes needed; orchestrate in `particle-system.js`.) 
* **Momentum clamp (optional toggle):** add a small reduction over `forceCurr` (reuse pyramid pattern on the particle texture) to compute mean force and subtract it once per frame for visibility tests. (You already have reduction machinery.) 

---

## G. Implementation order (minimal disruption path)

1. **Textures & MRT wiring:** allocate per‑level **A1/A2** attachments; update FBO/drawBuffers; extend `aggregation` and `reduction` to output all three attachments (no traversal changes yet).   
2. **Scheduler:** switch `step()` to **KDK** with `forcePrev/forceCurr` (forces still computed with the current traversal).   
3. **Traversal—MAC cleanup:** change the level loop to **[Lmax..L1]** and keep **L0** only in the near‑field block to avoid level‑0 double counting. Implement **offset‑MAC** using `δ`. 
4. **Traversal—Quadrupole:** read **A1/A2**, assemble **Q**, and add the quadrupole term for **accepted** nodes only. Keep near‑field as direct monopole. 
5. **Tuning:** sweep `theta` and `softening` to regain perf with lower artifacts.

---

## H. Pseudocode index (what to implement where)

* **Aggregation shaders**
  `aggregation.vert.js`:

  ```
  // add varyings for A1/A2; compute x²,y²,z²,xy,xz,yz times mass
  ```

  `aggregation.frag.js`:

  ```
  // write to outA0,outA1,outA2 with additive blending (MRT)
  ```

   

* **Reduction shader**
  `reduction.frag.js`:

  ```
  // for each parent voxel: sum 8 child texels for A0,A1,A2 and write to three outputs
  ```



* **Traversal shader**
  `traversal.frag.js`:

  ```
  function cellCenter(level, voxel) -> vec3
  function accepted(level, voxel, com, targetPos, theta) -> bool
  function accumulateMonopoleAndQuadrupole(level, voxel, targetPos, inout vec3 a):
      // fetch A0 (mass, sumPos), A1, A2
      // com = sumPos / mass
      // build raw M2 from A1/A2
      // S = M2 - mass * outer(com,com)
      // Q = 3*S - trace(S)*I
      // r = com - targetPos
      // add monopole a += G * mass * r / (|r|^2 + eps^2)^(3/2)
      // add quadrupole a += G * ( Qr / |r|^5 - 2.5 * (r·Qr) * r / |r|^7 ), Qr = Q*r

  // main:
  a = accumulateFarField over levels [Lmax..L1] with offset-MAC
  a += accumulateNearFieldL0 direct-sum
  write a to force texture
  ```



* **Host scheduling & integration**
  `particle-system.js`:

  ```
  class ParticleSystem {
    step_KDK()
    kick(dtScale, forceTex)        // bind vel_integrate.frag with u_dt * dtScale, u_force=forceTex
    drift(dt)                      // bind pos_integrate.frag with u_dt=dt
    buildQuadtree_WithQuadrupoles()// clears, runs aggregation_MRT, then reduction_MRT
    accumulateForces_WithQuadrupoles(outForceTex)
  }
  ```

  Uses your existing `createProgram`, `createTextures`, VAOs, and pipeline calls; only the order and attachments expand.   

---

### What you get from Plan C

* **Better pruning at same visual error** (offset‑MAC + quadrupoles) → more FPS.
* **Calmer dynamics** (less directional bias, symplectic KDK) without a full data‑structure rewrite.
* **Minimal changes to the overall architecture**: your pyramid stays; you extend it with **two MRT attachments** and tweak traversal + integrator ordering. 

If you want, I can next outline **exact uniform names, attachment indices, and per‑level binding tables** so wiring the MRT FBOs and sampler units is straightforward, still sticking to function signatures + pseudocode only.
