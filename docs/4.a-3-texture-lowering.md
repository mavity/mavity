# 4.a-3 Texture lowering: reduce FFT working buffer footprint

Status: draft

Summary
-------
This note documents a concrete plan to lower the texture formats used by the PM/FFT spectral pipeline to reduce memory and avoid copy-format errors observed at runtime (GL_INVALID_OPERATION from glCopyTexSubImage2D). The core idea: separate single-channel mass storage from complex spectra and make the FFT working buffer use RG32F instead of RGBA32F.

Motivation / Why this started
--------------------------------
- A runtime error was observed during inverse FFT: "GL_INVALID_OPERATION: glCopyTexSubImage2D: Invalid copy texture format combination". Investigation showed a copy from an RG32F source to an RGBA32F destination.
- The pipeline currently reuses `psys.pmSpectrum.texture` (allocated as RGBA32F) as the FFT working buffer; FFT semantics use only R/G as complex (real/imag), so half the channels are unused during FFT.
- Mass deposition / converter semantics also mismatched (deposit shader wrote mass to R while converter read A), compounding diagnostic confusion about zero density.

What we learned (exact, concrete)
---------------------------------
- `pmGrid.texture` (mass grid) is created as gl.RGBA32F; current deposit shader in this workspace writes mass into R (outColor.r = mass) but `convertRealToComplex` reads mass from `.a` (texture(...).a).
- `psys.pmSpectrum.texture` is allocated as gl.RGBA32F (4 channels) and reused as the FFT working buffer. The FFT code and shaders use only R/G as complex (Re/Im).
- `pmDensitySpectrum`, `pmPotentialSpectrum`, `pmForceSpectrum` are RG32F (R=real, G=imag). `pmForceGrids` and `pmForceTexture` are RGBA32F real-space outputs.
- Inverse pipeline copies an `inputSpectrum` (RG32F) into `psys.pmSpectrum.texture` using gl.copyTexSubImage2D which fails when the destination is RGBA32F.

Goal
----
1. Reduce working buffer memory by using RG32F for `psys.pmSpectrum.texture` and its ping-pong partner. That yields ~50% channel occupancy reduction for the FFT stage.
2. Eliminate the RG32F ↔ RGBA32F copy-format mismatch that caused 0x502.
3. Keep semantics correct: mass must be read by `convertRealToComplex` from the place deposit writes it, or vice versa, and final per-particle mass bookkeeping remains available for debug if needed.

Concrete change plan (minimal, ordered)
-------------------------------------
1. Add single-channel mass texture
   - Create `psys.pmMassTexture` (internal gl.R32F, format gl.RED) and corresponding FBO `psys.pmMassFBO`.
   - Use this texture for deposition output instead of the full `pmGrid.texture` when performing particle deposit.

2. Update deposit stage
   - Bind and write additive mass into `pmMassFBO` in deposit pass (fragment shader writes mass into R channel). Use gl.ONE, gl.ONE blending.
   - Adjust `pm-deposit.frag.js` to output mass into R (outColor = vec4(mass, 0, 0, 0)) if writing to single-channel with correct attachment; or continue writing A if that is preferred (choose R to match single-channel).

3. Update convert shader
   - Change `convertRealToComplex` (in `pm-fft.js` / configureRealToComplex) to read mass from `.r` (or `.a` depending on deposit change) — keep semantics consistent.

4. Lower pmSpectrum working buffer to RG32F
   - Allocate `psys.pmSpectrum.texture` and its pingPong as gl.RG32F (internal gl.RG32F, format gl.RG, type gl.FLOAT).
   - Update any helpers that created RGBA32F spectrum textures to use RG32F for the working buffer.

5. Ensure pmDensitySpectrum / pmPotentialSpectrum / pmForceSpectrum remain RG32F
   - These are already RG32F in the codebase; ensure copy/blit paths now use compatible formats.

6. Fix inverse FFT copy
   - After making pmSpectrum RG32F, the current copy (copyTexSubImage2D or blitFramebuffer) between RG32F textures will be valid; alternatively replace the copy with a shader blit that samples the source and writes R/G explicitly to the working buffer (format-agnostic and explicit mapping).

7. Per‑particle force/mass split (optional but recommended)
   - Optionally store per-particle mass in a separate R32F `psys.pmParticleMass` texture; `pmForceTexture` can be kept RGB for forces only. Update `pm-force-sample` to write mass to the separate texture and update debug readers.

Shaders that must be edited
---------------------------
- `pm-deposit.frag.js` (change output channel to R or A consistently with `convertRealToComplex`).
- `pm-fft.js::configureRealToComplex` (read texture(...).r or .a according to deposit).
- Allocation sites in `particle-system-spectral.js` (change createRGBA32Texture -> createRG32Texture for pmSpectrum and pingPong where appropriate).
- `inverseFFTToReal` copy logic (either rely on compatible formats after change or replace copyTexSubImage2D with a shader blit).
- Debug helpers / inspectors that read/assume RGBA for pmSpectrum or pmGrid — update readPixels formats (use gl.RG / gl.RED for RG32F / R32F reads).

Why this is safe (texture‑unit and sampler limits)
-------------------------------------------------
- Audit of pipeline passes shows maximum simultaneous sampler usage is 4 (force sampling), and every pass that reads mass reads a single texture. Splitting mass into its own texture does not increase the peak number of simultaneous samplers.
- WebGL2 minimum texture unit counts (typically 8–16) exceed the pipeline peak; splitting will not hit sampler limits.

Testing & verification steps
----------------------------
1. Unit smoke test: run the Spectral pipeline with debug enabled and ensure logs show all stages: deposit, forward FFT, poisson, gradient, inverse FFT, force sampling.
2. Inspect mass grid: read `pmMassTexture` to ensure non-zero mass contributions. (Use debug/texture-inspector helpers.)
3. Verify forward FFT: after `convertRealToComplex` inspect `psys.pmSpectrum.texture` (RG) to confirm mass loaded into R and G == 0.
4. Verify forward FFT result: inspect `pmDensitySpectrum` (RG) R/G for complex values and confirm DC amplitude equals total mass.
5. Verify inverse path: for each force axis, copy/load `pmForceSpectrum.axis.texture` into working `pmSpectrum.texture`, run inverse FFT, run `extractReal` and check `pmForceGrids` real outputs.
6. Integration test: run full sim for several frames and ensure no GL errors (particularly no 0x502) and particles move plausibly.

Rollback / mitigation
---------------------
- If devices without required color buffer float support fail, revert pmSpectrum allocation to RGBA32F and instead implement a shader-blit copy in `inverseFFTToReal` to perform explicit channel packing from RG → RGBA. This preserves functionality at the cost of memory.

Post-change: handling the original copying situation
--------------------------------------------------
- After lowering pmSpectrum to RG32F and making pmForceSpectrum / pmDensitySpectrum RG32F, the format mismatch that caused the 0x502 disappears and the current copy/blit code will work.
- If we prefer not to change pmSpectrum, the alternative is to replace the direct GPU copy with a shader blit that reads RG source and writes into RGBA destination mapping channels explicitly (costs a draw pass but avoids format constraints).

Estimated memory effect
-----------------------
- For an N×N packed texture (textureSize), switching pmSpectrum from RGBA32F → RG32F halves that texture's footprint (16 B/texel → 8 B/texel). Exact overall savings depend on how many other RGBA32F buffers remain.

Follow-ups
----------
- Implement and test the minimal change (split mass + lower working buffer). Measure memory and perf. If successful, consider also separating per-particle mass from `pmForceTexture.a`.
- Add a short automated verification that checks format compatibility before calling gl.copyTexSubImage2D / blitFramebuffer and falls back to shader blit if needed.

References (code locations)
--------------------------
- Deposit: `gravity-spectral/pm-deposit.js`, `shaders/pm-deposit.frag.js`
- Convert: `gravity-spectral/pm-fft.js::configureRealToComplex`
- Working buffer allocation: `particle-system-spectral.js` (pmSpectrum create)
- Inverse copy: `gravity-spectral/pm-fft.js::inverseFFTToReal` (copyTexSubImage2D)
- Gradient: `gravity-spectral/pm-gradient.js` (pmForceSpectrum creation)
- Force sampling: `gravity-spectral/pm-force-sample.js` (writes `pmForceTexture`)

---
End of plan.
