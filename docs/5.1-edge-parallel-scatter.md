# Blueprint 1: Edge‑parallel scatter with additive blending

This is focused on _how to make it scream_ on WebGL2, plus the corner cases you’ll hit at scale and how to schedule around them.

---

## 0) One‑line mental model

Treat each **edge** as a tiny “message” that contributes an **equal‑and‑opposite force** to its two endpoints. We **draw one pixel‑sized point per contribution** and use **additive blending** so the GPU’s ROP/back‑end sums all contributions directly into a per‑node **acceleration texture**—**no atomics** needed, no read‑modify‑write on the CPU.

---

## 1) Capability gates (what must be true on the device)

To blend into floating‑point textures you need **both**:

1. **`EXT_color_buffer_float`** – makes float formats **render‑targetable** (R16F/RG16F/RGBA16F, R32F/RG32F/RGBA32F). ([MDN Web Docs][1])
2. **`EXT_float_blend`** – **enables blending** when those render targets have **32‑bit float components**. Without it, enabling `gl.BLEND` while rendering to `RGBA32F`/`RG32F` is an error. ([MDN Web Docs][2])

> **Practical rule:** If `EXT_float_blend` is missing, don’t try to “limp along” with scatter; switch to **Blueprint 2 (CSR gather)** for determinism/portability. Use `EXT_disjoint_timer_query_webgl2` to profile and make device‑specific decisions. ([Khronos Registry][3])

---

## 2) Data layout for bandwidth and cache locality

### 2.1 Node state (unchanged from your pipeline)

- `positionTex`: `RGBA32F` (x,y,z,·), **NEAREST** sampling, `texelFetch`.
- `accTex`: `RGBA32F` accumulation (x,y,z,·) with blending.

### 2.2 Edge table (COO, edge‑parallel)

- `edgesTex`: `RG32F` → `(srcIdx, dstIdx)`. 8 bytes/edge.
- Optional `weightTex`: `R16F` or `R32F` (edge weight, rest length, etc.).
- **Index encoding:** store `int` as **32‑bit float**; exact up to ~16.7 M distinct IDs.

> Allocate with `texStorage2D` and fill via `texSubImage2D`. Keep filters at **NEAREST**, wrap **CLAMP_TO_EDGE**.

---

## 3) The core draw: one instanced pass, two contributions per edge

You can push **two point writes per edge** in a single draw by using instancing:

- **Instances = 2 · E**
  `edgeId = gl_InstanceID >> 1;   toSrc = (gl_InstanceID & 1) == 0;`
- Compute force **once** per edge; write `+f` to **src** and `−f` to **dst** (or vice versa).

**Vertex shader (sketch):**

```glsl
#version 300 es
precision highp float; precision highp int;

uniform sampler2D uEdges;        // RG32F: (src, dst)
uniform sampler2D uPos;          // RGBA32F: positions
uniform ivec2 uEdgeSize, uNodeSize;
uniform float uK, uRest;         // params (or fetch per-edge)
uniform float uSoft;             // softening

out vec3 vForce;

ivec2 uv1D(int idx, ivec2 sz){ return ivec2(idx % sz.x, idx / sz.x); }
int   iFetch(sampler2D t, ivec2 sz, int idx){ return int(texelFetch(t, uv1D(idx, sz), 0).x + 0.5); }
vec3  pFetch(int node){ return texelFetch(uPos, uv1D(node, uNodeSize), 0).xyz; }
vec4  eFetch(int eid){ return texelFetch(uEdges, uv1D(eid, uEdgeSize), 0); }

vec2 nodePixel(int node, ivec2 size){
  return vec2(node % size.x, node / size.x);
}
vec2 pixelToClip(vec2 pix, ivec2 size){
  vec2 n = (pix + vec2(0.5)) / vec2(size);
  return n * 2.0 - 1.0;
}

void main(){
  int inst  = gl_InstanceID;
  int eid   = inst >> 1;
  bool toSrc= (inst & 1) == 0;

  vec4 e    = eFetch(eid);
  int src   = int(e.x + 0.5);
  int dst   = int(e.y + 0.5);

  vec3 ps   = pFetch(src);
  vec3 pd   = pFetch(dst);
  vec3 d    = pd - ps;
  float r2  = max(dot(d,d), uSoft*uSoft);
  float invr= inversesqrt(r2);                // fast 1/sqrt
  float r   = 1.0 / invr;

  // Example: simple spring toward rest length (linear)
  vec3 f    = uK * (r - uRest) * (d * invr); // unit(d) * displacement

  int target = toSrc ? src : dst;
  vec2 pix   = nodePixel(target, uNodeSize);
  gl_Position = vec4(pixelToClip(pix, uNodeSize), 0.0, 1.0);
  gl_PointSize = 1.0;

  vForce = toSrc ? f : -f;                    // equal & opposite
}
```

**Fragment shader:**

```glsl
#version 300 es
precision highp float;
in vec3 vForce;
layout(location=0) out vec4 outAcc;
void main(){ outAcc = vec4(vForce, 0.0); }    // blended add
```

**GL state (critical):**

```js
gl.bindFramebuffer(gl.FRAMEBUFFER, fboAcc); // color0 = accTex (RGBA32F)
gl.drawBuffers([gl.COLOR_ATTACHMENT0]); // MRT optional
gl.viewport(0, 0, nodeW, nodeH);

gl.disable(gl.DEPTH_TEST);
gl.disable(gl.STENCIL_TEST);
gl.colorMask(true, true, true, true);

// Blend = pure addition
gl.enable(gl.BLEND);
gl.blendEquation(gl.FUNC_ADD);
gl.blendFunc(gl.ONE, gl.ONE); // additive

// Draw 2E instances
gl.drawArraysInstanced(gl.POINTS, 0, 1, 2 * E);
```

> **Why this is fast:** each fragment writes one pixel and **adds** its vec3 to what’s already there. The **ROP/blend unit** does the accumulation—no shader atomics, no critical‑section logic. (This mirrors what large WebGL graph engines like **Cosmograph** do to reach 100k+ nodes/links interactively.) ([GitHub][4])

---

## 4) Precision & formats

- Prefer **`RGBA32F`** for accumulators when possible (guarantees blending with `EXT_float_blend`). Half‑float can saturate with thousands of contributions. ([MDN Web Docs][2])
- Keep positions as **`RGBA32F`** to avoid normalization/precision artifacts over large spatial ranges.
- Use **`texelFetch`** (integer texel coords) so no filtering/LOD costs.

---

## 5) Scheduling: how to keep the back‑end fed (and not overwhelmed)

The bottleneck in scatter is usually **blend/ROP bandwidth** and **memory traffic**, not ALU. Here are the playbooks that matter:

### 5.1 **Edge tiling (always do this)**

- Split the edge list into **tiles of 0.5–5 M edges** per draw call (platform‑dependent).
- Between tiles, optionally **flush** by drawing a 1×1 dummy primitive to a different FBO to help drivers submit (rarely needed, profile first).
- Instrument with **`EXT_disjoint_timer_query_webgl2`** and auto‑tune tile size at startup. ([Khronos Registry][3])

### 5.2 **Destination macro‑tiling (optional, often a win)**

- Partition node texture into **macro‑tiles** (e.g., 64×64 or 128×128 pixels).
- Pre‑bucket edges by **destination macro‑tile** (and, in a second pass, by **source macro‑tile**; see 5.3).
- Render bucket‑by‑bucket using **`gl.scissor`** to limit writes to the destination tile region.
  This increases **locality** in the ROP cache and reduces cross‑tile interference. (Classic graphics trick: keep writes spatially clustered.) ([NVIDIA Developer][5])

> **Trade‑off:** macro‑tiling shines when many writes hit nearby pixels (clusters, hubs). If your graph is uniformly random, tiling helps less.

### 5.3 **Two‑pass split for locality (dest then src)**

- Instead of emitting **two instances per edge in one draw**, do **two draws**:

  1. **Dest pass:** one instance per edge → write contribution to `dst` only.
  2. **Src pass:** one instance per edge → write contribution to `src` only.

- Why? It lets you **macro‑tile and scissor by the active endpoint** (dest in pass 1, src in pass 2), which significantly improves locality—especially if paired with **sort‑by‑endpoint** inside each tile.
- Cost: **2×** edge reads and transforms. Often still a net win when ROP contention is the wall.

### 5.4 **Edge ordering to exploit caches**

- **Sort edges by `dst`** (for dest pass) or by `src` (for src pass).
  Consecutive fragments then write to **adjacent pixels**, which keeps the tile’s color buffer hot in the cache.
- Secondary key: sort by the **other endpoint** to maximize reuse of position fetches in L1/L2.
- Combine with **periodic node reindexing by space‑filling curve** (Hilbert/Morton) based on _current_ positions so that “nearby in space ≈ nearby in memory” for both reads and writes. (This is routinely effective in particle/mesh codes.) ([library.eecs.utk.edu][6])

### 5.5 **Hub handling (don’t serialize the back‑end)**

Heavy‑degree nodes can attract **thousands of blended writes** to the _same pixel_ in one tile → back‑end serialization. Use a **hybrid** policy:

- **Detect hubs** (degree > threshold, e.g., >4k or >2×median).
- **Exclude their incident edges from scatter**, and compute the hub’s force via a **gather micro‑kernel** (Blueprint 2) that sums neighbors into a **single write**.
- Everything else stays in the fast scatter path.

This “hub offload” avoids pathological per‑pixel contention with minimal extra code (you already have the gather path).

### 5.6 **Stochastic micro‑batching (when E is huge)**

- Process only a **random p‑fraction of edges** per frame; scale those contributions by `1/p`.
- Cycle batches across frames; with your **KDK integrator** and mild damping this converges smoothly while keeping **per‑frame ROP traffic** bounded.
- Degree‑aware sampling (raise p for hubs) improves stability.

---

## 6) Micro‑optimizations inside the shader

- **One sqrt per edge**: use `inversesqrt(dot(d,d)+eps)` and multiply—avoid `normalize(d)` + separate `length()`.
- **Branchless softening:** `r2 = max(dot(d,d), soft^2)`. Avoid `if(r<eps)`.
- **Pack per‑edge scalars** in a single `RG16F`/`RG32F` texture to reduce samplers.
- **Pre‑scale constants** on CPU (e.g., fold `G*dt` or spring constants).
- **Avoid dynamic flow**; keep the shader straight‑line so the driver can unroll and schedule well.

---

## 7) Multi‑render targets (MRT): squeeze more work per pass

WebGL2 lets you write to **multiple attachments** in one draw. Use it to accumulate **aux channels** alongside acceleration:

- `accTex0 (RGB)`: force contribution (this is your main target).
- `accTex1 (R)`: **degree sum** or **weight sum** for per‑node normalization or diagnostics.
- `accTex2 (RGB)`: optional **debug** (e.g., last edge’s unit vector).

Just remember **blending applies independently per attachment** but with the **same blend func**. Set up with `drawBuffers`. ([MDN Web Docs][7])

---

## 8) GL state & pipeline hygiene checklist

- Disable everything you don’t need: `DEPTH_TEST`, `STENCIL_TEST`, `CULL_FACE`.
- **Point rasterization**: use `gl_PointSize = 1.0`. (Large points have portability caveats; we’re writing **exactly one pixel**.) ([Stack Overflow][8])
- Set `gl.colorMask(true,true,true,true)`; if you don’t use alpha, consider `false` on A to save bandwidth (minor).
- Minimize `useProgram`/`bindTexture` churn: bind edge and position textures once per tile; use **uniforms** for ranges/offsets to avoid rebinding.
- Allocate textures with **`texStorage2D`** (immutable) for better driver behavior.
- If you clear the accumulator, use **`gl.clearBufferfv`** (fast path).

---

## 9) Instrumentation: know your wall

- Wrap each pass with **`EXT_disjoint_timer_query_webgl2`**; skip results when `disjoint` is set. Build a moving average and auto‑tune **edge‑tile size**, **macro‑tile dims**, and **pass split** (1‑pass vs 2‑pass). ([Khronos Registry][3])
- Keep a live **degree histogram** and **hot‑pixel counter** (writes per node this frame). If a node exceeds a threshold, move it to the **hub gather** list for the next frame.
- Measure **blend saturation** by temporarily rendering to an **INT** target with `min(1, writeCount)` logic (debug mode) to visualize hotspots.

---

## 10) Putting it together: three production‑ready variants

### Variant A — **One‑pass scatter (fast path)**

- **Prereqs:** `EXT_color_buffer_float` + `EXT_float_blend`.
- **What:** single draw, `2E` instances, each edge writes to **both endpoints**.
- **When:** general case on desktop GPUs; best throughput / simplest code.
- **Mix with BH:** write directly into the **same acc buffer** as BH (ensure BH pass finishes first and targets are cleared). If needed, separate them and do a cheap **combine** pass.

### Variant B — **Two‑pass scatter (dest then src)**

- **Prereqs:** same as A.
- **What:** two draws, **`E` instances** each; sort/bucket by the active endpoint and **scissor** to the destination macro‑tile.
- **When:** ROP is the wall; heavy hotspot pixels; need more locality. Accept **2× ALU**/fetches to reduce back‑end contention.

### Variant C — **Hybrid (scatter for most, gather for hubs)**

- **Prereqs:** same as A.
- **What:** run **Variant A** on edges whose endpoints both have degree < `T`; for the rest, **skip** in scatter and process those nodes via **Blueprint 2** (CSR gather shards) to produce one write per hub.
- **When:** social graphs with power‑law tails; avoids per‑pixel serialization at hubs with minimal extra code.

---

## 11) Stability & numerics

- **Nondeterminism:** additive blending sums in arbitrary order; for forces this is nearly always fine. If you need bit‑for‑bit determinism for testing, reroute to **gather + segmented reduction** (Blueprint 2) and compare.
- **Dynamic range:** with thousands of contributions per node, prefer **32‑bit floats** for accumulators (half‑float can denormal/overflow). ([GitHub][9])
- **Integrator:** keep your **KDK** and **maxAccel clip**; if you mini‑batch edges, mildly increase damping or reduce `dt`.

---

## 12) Real‑world precedent

- **Cosmograph / cosmos.gl** performs large‑graph layouts entirely in WebGL shaders and uses GPU blending and tiled passes to reach interactive rates with **hundreds of thousands** of nodes/links in the browser. It validates the feasibility of this blueprint. ([GitHub][4])

---

## 13) Drop‑in “accumulateEdgesScatter()” call (pseudocode)

```js
function accumulateEdgesScatter({
  gl,
  program,
  fboAcc,
  accTex,
  edgesTex,
  posTex,
  nodeW,
  nodeH,
  edgeTiles, // edgeTiles: array of {offset, count} or {destTileId, offset, count}
}) {
  gl.bindFramebuffer(gl.FRAMEBUFFER, fboAcc);
  gl.framebufferTexture2D(
    gl.FRAMEBUFFER,
    gl.COLOR_ATTACHMENT0,
    gl.TEXTURE_2D,
    accTex,
    0
  );
  gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
  gl.viewport(0, 0, nodeW, nodeH);

  gl.disable(gl.DEPTH_TEST);
  gl.disable(gl.STENCIL_TEST);
  gl.enable(gl.BLEND);
  gl.blendEquation(gl.FUNC_ADD);
  gl.blendFunc(gl.ONE, gl.ONE);

  gl.useProgram(program);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, edgesTex);
  gl.uniform1i(gl.getUniformLocation(program, "uEdges"), 0);
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, posTex);
  gl.uniform1i(gl.getUniformLocation(program, "uPos"), 1);

  for (const tile of edgeTiles) {
    // Optional macro-tiling: set scissor to the node macro-tile rectangle for DEST pass
    if (tile.scissor) {
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(...tile.scissor);
    }
    gl.uniform2iv(uEdgeRange, [tile.offset, tile.count]); // shader interprets gl_InstanceID within this range
    gl.drawArraysInstanced(gl.POINTS, 0, 1, tile.count * 2);
    if (tile.scissor) gl.disable(gl.SCISSOR_TEST);
  }
}
```

(If you choose **Two‑pass split**, call the function twice with two programs—`emitDestOnly` / `emitSrcOnly`—and edge tiles sorted/bucketed by the relevant endpoint.)

---

## 14) Quick validation harness

1. Run on a **tiny graph** (e.g., N=128, E=1k); compute forces on CPU and compare to GPU within tolerance.
2. Overstress a **synthetic hub** (degree 32k) and confirm hybrid mode (hub→gather) restores FPS vs pure scatter.
3. Turn on **macro‑tiling** (e.g., 128×128) and check timer query deltas for ROP improvements. ([Khronos Registry][3])

---

## 15) What to expose in THREE‑g

- `graphForces: { mode: 'scatter' | 'split' | 'hybrid', hubThreshold, macroTile: [Tw,Th], sampleRate }`
- `caps: { floatBlend: boolean }` – detect `EXT_color_buffer_float` and `EXT_float_blend` once. ([MDN Web Docs][1])
- `profile: { edgeTileSize, macroTile, hubCount, blendMs }` – surface timer results so apps can auto‑tune.

---

### Final takeaway

Edge‑parallel scatter with additive blending is **the** simplest **and** fastest way to do massive per‑edge force accumulation on WebGL2—**if** you (a) have the two float extensions, and (b) schedule for **blend locality** and **hub fairness**. Use **edge tiling**, **macro‑tiling + scissor**, **endpoint‑sorted passes**, and a **hybrid gather fallback for hubs**. That playbook keeps the ROPs busy without starving on hotspots, and it scales right up to the hardware’s blend bandwidth.

If you want, I can turn this into a ready‑to‑drop **scatter module** (shader + JS harness) that includes **split** and **hybrid** variants behind a runtime capability check and a tiny autotuner using timer queries.

[1]: https://developer.mozilla.org/en-US/docs/Web/API/EXT_color_buffer_float?utm_source=chatgpt.com "EXT_color_buffer_float extension - Web APIs | MDN"
[2]: https://developer.mozilla.org/en-US/docs/Web/API/EXT_float_blend?utm_source=chatgpt.com "EXT_float_blend extension - MDN Web Docs"
[3]: https://registry.khronos.org/webgl/extensions/EXT_disjoint_timer_query_webgl2/?utm_source=chatgpt.com "WebGL EXT_disjoint_timer_query_webgl2 Extension Specification"
[4]: https://github.com/cosmosgl/graph?utm_source=chatgpt.com "GPU-accelerated force graph layout and rendering - GitHub"
[5]: https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-28-graphics-pipeline-performance?utm_source=chatgpt.com "Chapter 28. Graphics Pipeline Performance | NVIDIA Developer"
[6]: https://library.eecs.utk.edu/files/ut-eecs-14-727.pdf?utm_source=chatgpt.com "Implementing a Sparse Matrix Vector Product for the SELL-C/SELL-C ..."
[7]: https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/drawBuffers?utm_source=chatgpt.com "WebGL2RenderingContext: drawBuffers() method - Web APIs | MDN"
[8]: https://stackoverflow.com/questions/58599089/draw-points-with-different-point-size?utm_source=chatgpt.com "webgl - Draw points with different point size - Stack Overflow"
[9]: https://github.com/gpuweb/gpuweb/issues/3556?utm_source=chatgpt.com "support blending 32 bit float textures · Issue #3556 · gpuweb/gpuweb"
