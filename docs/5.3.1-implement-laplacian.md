# 5.3.1 Implement Laplacian (Blueprint 3) and plug into Quadrupole

This document describes a concrete, minimal‑risk implementation plan to add
Blueprint 3 (Laplacian springs = SpMV) to THREE‑g and wire it into the
`ParticleSystemQuadrupole` pipeline. It contains API changes, CPU/GPU data
layouts, shader pass sequencing, the gravity modification requested, a demo
edge generator for social graphs (demo.js), tests, and rollout notes.

Goals
- Implement CSR → sharded partials → segmented reduction SpMV pipeline on WebGL2.
- Wire into `ParticleSystemQuadrupole` via a small ForceModule API.
- Accept edges from caller as `Iterable<{from:number,to:number,strength:number}>`.
- Modify gravity: normal attraction until softening threshold `N`, inside `N` switch to linear repulsion to avoid collapse.
- Provide a demo graph generator that mimics social graphs (many low‑degree nodes, heavy‑tailed hubs, cliques and clusters).

High level design
1. API & wiring
   - Extend `ParticleSystemQuadrupole` constructor options with optional `edges` input.
     - `edges` is an Iterable of { from, to, strength } where `from` and `to` are particle indices (0..N-1).
   - Add instance methods on `ParticleSystemQuadrupole`:
     - `registerForceModule(module)` (optional) — used internally when edges are provided.
     - `unregisterForceModule(module)`.
   - Internally create a `LaplacianForceModule` when `options.edges` is present and register it automatically.

2. ForceModule contract (LaplacianForceModule specifics)
   - init(gl, opts): builds CSR, degree arrays, shards, uploads textures, compiles shaders.
     - opts: { particleCount, textureWidth, textureHeight, softening, disableFloatBlend }
   - accumulate({ targetForce, positionTextures, currentIndex, dt, forKDKPhase }): runs the SpMV pipeline and writes contributions into `targetForce.framebuffer` (per‑node acceleration) in the same coordinate system used by existing forces.
   - dispose(): delete textures, buffers, programs.

3. CPU preprocessing: build CSR and shards
   - Build adjacency arrays from `edges` (both directions if undirected; accept as undirected by default).
   - rowPtr: length N+1 ; colIdx: length E ; weight: length E.
   - deg[i] = sum_j w_ij.
   - Shard generation: choose L=64 (tunable). For node i with degree d: generate ceil(d/L) shards with record { nodeId, start, len }.
   - Compute #shards S and pack shards into `RGBA32F` texture (nodeId, start, len, 0).

4. GPU textures (typical choices)
   - Positions: reuse `positionTextures` (RGBA32F, x,y,z,mass). Use `texelFetch` by integer coords.
   - colIdx: `R32F` texture (E length), each texel.x contains float-encoded integer neighbor index.
   - weight: `R32F` or `R16F` depending on precision need.
   - shards: `RGBA32F` (S length) with (nodeId, start, len, 0).
   - deg: `R32F` (N length).
   - partials: `RGBA32F` ping-pong textures sized to S (one texel per shard) for pass1 outputs.
   - Ax (aggregated neighbor sums): `RGBA32F` (N length) final per-node aggregated neighbor weighted positions.

5. Shader passes
   - Pass 1: partials shader (one fragment per shard)
     - Inputs: `uShards`, `uColIdx`, `uWeight`, `uPos`.
     - Loop k in [0,L): if k<len fetch e=start+k, idx=colIdx[e], w=weight[e], xj=pos[idx], accumulate sumx += w*xj.
     - Output `outPartial = vec4(sumx.xyz, sumWeight)`.
   - Pass 2: reduce partials → Ax
     - If `EXT_float_blend` available and `!disableFloatBlend`:
       - Render one point per partial; in VS place point at pixel location for `nodeId` and FS output partial; enable additive blending (ONE,ONE) into Ax texture of size N.
     - Else: segmented reduction shader (log steps) using ping-pong partials and `nodeShardPtr` to compact the head-of-segment values into Ax.
   - Pass 3: laplacian finish (per-node)
     - Inputs: Ax, deg, pos[i]
     - Compute F_attr = k * (Ax - deg[i] * pos[i]) (where k is spring constant). For normalized / outbound distribution, scale weights by 1/deg[src] at CSR build time or use degInv.
     - Write into the `targetForce` FBO as additive contribution (either write directly or combine with existing target content depending on state). The module will assume `targetForce` has been cleared or contains BH forces already depending on call sequence.

6. Integration into Quadrupole KDK
   - Quadrupole uses `accumulateForces(forceTex)` helper to compute gravitational traversal outputs into provided `forceTex`.
   - Modify `accumulateForces(forceTex)` to:
     1. Run existing traversal/gravity pipeline into `forceTex` as before.
     2. Call `this.laplacianModule.accumulate({ targetForce: forceTex, positionTextures: this.positionTextures, currentIndex: this.getCurrentIndex(), dt: this.options.dt, forKDKPhase })` to accumulate edge forces into the same `forceTex` (so both halves use consistent combined forces).
   - For the KDK flow `step_KDK()` ensure the `accumulateForces(this.forceTexturePrev)` call computes both gravity + laplacian into `forceTexturePrev`.

7. Gravity modification (softening threshold N)
   - Let `N = this.options.softening` (current softening constant).
   - Replace gravity contribution in per-node gravity shader (or add small extra pass) with behaviour:
     - Let r = distance to origin (||pos||).
     - If r >= N: gravity force Fg = -G * pos (normal attractive behavior: pulls to origin).
     - If r < N: switch to repulsive behavior that increases linearly from 0 at r==N to a maximum repulsion at r==0.
       - One convenient linear mapping: let t = 1 - r/N; Fg = +C * t * pos / (r + eps) (sign reversed to push outwards). Choose C so that magnitude at r==0 is comparable to typical spring strengths; e.g., C = k * 0.5 or a fraction of `options.gravity`.
   - Implement this in traversal/force finish shader (where gravity is currently added) so BH repulsion + laplacian attraction don't collapse particles.

8. Demo graph generator (demo.js)
   - Provide function `generateSocialGraph(N, avgDegree, clusterCount)` that returns nodes[] and edges[] Iterable with edge strengths:
     - Create `clusterCount` clusters. For each cluster create a clique (or near-clique) of size sampled from power-law distribution; connect clusters with inter-cluster edges at lower probability.
     - Add many low-degree random nodes: for N_total = N, reserve ~60% as low-degree nodes (degree 1–3), 30% as medium (4–16) and 10% as hubs (degree > 50) to create a heavy-tailed degree distribution.
     - For each edge set strength = random in [0.5, 1.5] or proportional to cluster cohesion.
   - The demo should show cliques, clusters and superclusters, and a heavy‑tailed global degree distribution.

9. Tests
   - CPU parity test on small graph (N<=1k, E<=5k): run CSR SpMV on CPU and compare per-node Ax and final F_attr with GPU results (within tolerance).
   - KDK integration smoke test: ensure velocities after half-kick and full-kick are consistent when laplacianModule is enabled vs disabled.
   - Performance smoke: N=10k, E ~50k, run a few frames and measure per-pass times with existing `GPUProfiler`.

10. Rollout plan
   - Step 1 (minimal): implement CSR builder + textures and the pass1 partials shader. Wire into quadrupole to output a debug `Ax` texture, but don't combine into forceTexture yet. Verify partials correctness via readback small test.
   - Step 2: implement reduction (blending path + segmented fallback) and laplacian finish shader. Add simple register/unregister API and auto-create module when `options.edges` supplied.
   - Step 3: integrate into KDK via `accumulateForces(forceTex)` and run parity tests.
   - Step 4: tune parameters (L, shard tile sizes), add optional reindexing/hilbert remap for locality, and finalize demo generator and README.

Implementation notes & caveats
- Use float-encoded integer indices in `colIdx` textures. Document the 16,777,216 safe limit.
- Keep shard size `L` configurable and use profiler to tune. Start with `L=64`.
- Prefer `R16F` for weights when possible to reduce memory. Use `R32F` for deg / pos.
- For segmented reduction, implement power-of-two ping-pong passes in GLSL; repo already has reduction helpers to reuse.
- If edges change dynamically, rebuild CSR/shards incrementally or rebuild every K frames.

Files to create/modify (suggested)
- New: `particle-system/force-modules/laplacian-force-module.js` — LaplacianForceModule implementation (CSR builder, uploader, shaders, accumulate()).
- Modify: `particle-system/particle-system-quadrupole.js` — accept `edges` in constructor options, auto-create module, call module from `accumulateForces(forceTex)` and expose `registerForceModule/unregisterForceModule`.
- New: `docs/5.3.1-implement-laplacian.md` (this file) — design doc.
- Modify: `demo.js` (or create demo file) — graph generator and example of passing `edges` into the particle system factory.

Estimated effort
- MVP (Pass1 partials + basic reduction via blending + laplacian finish + wiring): ~2–3 coding days (dev + small tests).
- Robust fallback segmented reduction, reindexing, and production tuning: additional 2–3 days.

---

If you approve this plan I will implement the `laplacian-force-module.js`, modify `particle-system-quadrupole.js` to accept `edges` and wire the module, and add a demo graph generator in `demo.js`. I will start with the minimal MVP (blending path + basic tests) and then add the segmented reduction fallback.

Once you confirm, I'll apply the changes and run quick smoke tests (CPU parity small graph + smoke integration).