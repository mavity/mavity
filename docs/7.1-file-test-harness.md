````markdown
# Daebug File-based REPL

This document describes daebug's markdown-based REPL system. Daebug replaces the legacy HTTP REPL with a file-based workflow using markdown files for debugging sessions.

The file protocol enables a tight request-result loop while keeping output readable and preserving history.

## Overview

- **Transport**: Markdown files in `daebug/` subdirectory
- **Initiation**: Edit a session file to add JavaScript code blocks
- **Orchestration**: Daebug watches session files, dispatches code to the matching page, writes back results
- **Registry**: `daebug.md` in repo root lists all connected pages and their session files
- **History**: All commands and results stay in session files; scroll to see past interactions
- **Verification**: Every REPL eval shows execution time. Always check this for debugging and performance tracking.

> Assume daebug server is already running. No need to start/stop the server.

## File Protocol

Daebug uses markdown files for REPL sessions. Each browser tab gets its own session file.

### Master Registry: `daebug.md`

The repo root contains `daebug.md` which lists all connected pages:

```markdown
# ðŸ‘¾ DAEBUG started at Sun Oct 20 2025 12:34:56 GMT+0100

> Master registry of connected pages and states.

* [6-dune-2040-42-webworker](daebug/6-dune-2040-42-webworker.md) (worker://6-dune-2040-42-webworker) last 12:35:14 state: idle
* [6-dune-2040-42](daebug/6-dune-2040-42.md) (http://localhost:8768/) last 12:35:14 state: idle
```

Click session links to open individual session files.

### Session File Format

Each session file in `daebug/` contains a conversation between you and the browser:

```markdown
# Session: 6-dune-2040-42

## Command at 12:35:20

```js
12 + 13
```

## Result at 12:35:20 (17ms)

```json
25
```

## Command at 12:35:30

```js
throw new Error("test error")
```

## Error at 12:35:30 (16ms)

```
Error: test error
    at eval (eval at <anonymous> (http://localhost:8768/:112:37), <anonymous>:1:7)
```

> 
```

The `> ` prompt at the bottom is where you add new commands.

### Adding Commands

1. Open a session file (e.g., `daebug/6-dune-2040-42.md`)
2. Scroll to the bottom
3. Add a JavaScript code block after the `> ` prompt:
   ````markdown
   ```js
   your code here
   ```
   ````
4. Save the file
5. Results appear within 1-2 seconds

### Result Format

Results include:
- **Execution time** â€“ Always displayed in ms (e.g., `(17ms)`)
- **Return value** â€“ Serialized as JSON when possible
- **Errors** â€“ Full stack trace in error blocks
- **History** â€“ All past commands and results remain visible

### Execution Timing

Always check execution time in result headers. This is critical for performance analysis. Example:
- `## Result at 12:35:20 (17ms)` â€“ Command took 17 milliseconds
- `## Error at 12:35:30 (16ms)` â€“ Error occurred after 16 milliseconds
// <page-name> <URL> <HH:MM:SS> idle
// <page-name> <URL> <HH:MM:SS> idle
// <page-name> <URL> <HH:MM:SS> idle
```

Notes:

- **Sorting**: by most recent heartbeat (`last`), unless there is an executing or last-completed page to pin at the top (see below).
- `HH:MM:SS` shows the pageâ€™s last poll time.

### 2) Request (debug actor writes a script)

```
// <page name or fragment>
<raw JavaScript to evaluate>
```

Rules:

- The first non-empty line must be a single-line comment naming the target page (partial match permitted; first match wins, same as HTTP REPL `name` fragment).
- Everything after the first line is raw JavaScript (expression or IIFE). Promises are awaited; return values are serialized to JSON, falling back to `String(value)` if not serializable.
- Make the file edit to submit the request.

### 3) Acknowledge (serve.js rewrites immediately)

```
// <executing-page> <URL> <HH:MM:SS> executing "<first 50 chars of code, newlinesâ†’space, â€¦ if long>" job=<id> started=<HH:MM:SS>
// <other-page> <URL> <HH:MM:SS>  <state>
// <other-page> <URL> <HH:MM:SS> <state>
```

Notes:

- The executing page is always pinned as the first header line while running.
- The code snippet is truncated to 50 visible characters, with `\n` replaced by a single space and an ellipsis if truncated.
- Job id and timestamp of start at the end of the line.

### 4) Success (result written back)

```
// <page> <URL> <HH:MM:SS> completed in <ms>ms (see below)
// <other-page> <URL> <HH:MM:SS> <state>
// <other-page> <URL> <HH:MM:SS> <state>
var result = <JSON-serialized result or String(value)>
```

Notes:

- The just-completed page remains pinned as the first header line (state: completed ok) until a new request is issued.
- The body contains a single `var result = ...` assignment without any trailing semicolon
- The assignment is the JSON formatted in multiple lines with 2-space indent
- The actor MUST check the execution time reported in the header for this REPL eval.

### 5) Error (stack verbatim)

```
// <page> <URL> <HH:MM:SS> failed after <ms>ms (see below)
// <other-page> <URL> <HH:MM:SS> <state>
// <other-page> <URL> <HH:MM:SS> <state>
<error stack verbatim, not JS>
```

Notes:

- The body is the raw error message/stack (no JS fencing or quoting), followed by finish info.
- The actor MUST check the "failed after <ms>ms" time in the header for this REPL eval.

### 6) Post-completion polling

- The completed header line stays as-is (not wiped back to idle) until the actor makes a new request by editing the file for any of the pages. Any new page execution request resets residual states to idle and wipes their results from the body below.
- All pages continue polling; their `last` timestamps in the header keep updating on a periodic refresh.
- The body (result or stack) stays until overwritten by the next REPL eval request.

## Session Management

### Multiple Sessions

- Each browser tab creates its own session file
- Web workers get separate session files with `-webworker` suffix
- Work with multiple sessions concurrently
- All sessions listed in `daebug.md`

### Page Reloads

- Refreshing a page creates a new session
- Old session files remain for history
- New session appears in `daebug.md` with updated timestamp

### Server Restart

To restart the daebug server:
1. Add `%%SHUTDOWN%%` on a separate line in `daebug.md`
2. Run `npm start` again from the oyinbo directory

## Tips

- **Session naming** â€“ Session names are auto-generated (e.g., `6-dune-2040-42`)
- **Finding commands** â€“ Scroll through session files to see command history
- **Multiple commands** â€“ Add multiple code blocks; they execute in sequence
- **Async operations** â€“ Use `await` inside async IIFEs
- **Performance tracking** â€“ Always check execution time in result headers
  - Executing: `// <name> <URL> <HH:MM:SS> executing "<snippet>" job=<id> started=<HH:MM:SS>`
  - Completed OK: `// <name> <URL> <HH:MM:SS> completed in <ms>ms (result below)`
  - Completed Error: `// <page> <URL> <HH:MM:SS> failed after <ms>ms (see below)`
  - Idle: `// <name> <URL> <HH:MM:SS> idle`
- **Pinned first line**:
  - If executing: the executing page is first.
  - Else if last-completed exists: that page is first (completed/failed).
  - Remaining lines sorted by most recent `last` timestamp.
- **Refresh cadence**: header is refreshed (e.g., ~1s) only when the header content actually changes, to minimize churn.

## Timing and Durations

- `startedAt`: when the page fetches the job (dispatch time).
- `finishedAt`: when the page posts the result/error.
- `duration = finishedAt - startedAt` displayed:
  - In header as `(<ms>ms)` or `(<X.Ys>)` when helpful.
    Header times show the pageâ€™s last heartbeat as `HH:MM:SS`.
- Requirement: For every REPL eval, the actor must check the measured execution time. Missing or anomalous durations should be treated as an error and investigated.

## Examples

### Idle header

```
// index-7-zen-12:01:03 http://localhost:8302/index 09:33:25 idle
// simplistic-5-nova-09:12:45 http://localhost:8302/simplistic 09:33:23 idle
// texture-11-echo-13:22:55 http://localhost:8302/texture 09:32:58 idle
```

Reminder: When you trigger a REPL eval from idle, check the execution time reported in the header upon completion.

### Request (actor makes edits)

```javascript
// index
(async () => {
  window.setMethod && window.setMethod("spectral");
  return "ok";
})();
```

Reminder: After submitting a REPL eval, plan to verify the time spent in execution when the result is written back.

### Acknowledge (serve.js rewrites)

```
// index-7-zen-12:01:03 http://localhost:8302/index 09:34:01 executing "(async () => { window setMethod && window..." job=12 started=09:34:01
// simplistic-5-nova-09:12:45 http://localhost:8302/simplistic 09:33:58 idle
// texture-11-echo-13:22:55 http://localhost:8302/texture 09:33:56 idle
```

Reminder: Once execution completes, check the reported duration ("completed in ..." or "failed after ...").

### Success (serve.js rewrites)

```
// index-7-zen-12:01:03 http://localhost:8302/index 09:34:02 completed in 742ms (result below)
var result = {
  "message": "ok"
}
```

Reminder: Verify and note the "completed in ..." time for this REPL eval.

### Error (serve.js rewrites)

```
// index-7-zen-12:01:03 http://localhost:8302/index 09:34:10 failed after 1,220ms (see below)
TypeError: Cannot read properties of undefined (reading 'fft')
    at <stack...>
    ...
```

Reminder: Verify and note the "failed after ..." time for this REPL eval.

## Concurrency and Safety

- **Single file job at a time**: while a file job is executing, new requests are ignored until completion. Submit the next request after the previous one completes.
- **Name matching**: partial match; first match wins (same semantics as HTTP REPL). Use distinctive titles to generate unique tab names.
- **Page not found**: `serve.js` rewrites header and body with `// page not found for "<fragment>"` and leaves the state idle.
- **Timeouts**: if no result within the server timeout (default 60s), header shows `completed error (timeout)`, body is `timeout` plus finish info.
- **Debounce and self-writes**: `serve.js` debounces reads and ignores its own write events to avoid feedback loops in editors.

## Implementation Notes (serve.js)

The following additions integrate file-based REPL without altering HTTP behavior:

- **Paths & constants**: `debug.js` path, snippet length (50), header refresh cadence (~1s), read debounce (~150ms).
- **Job model**: jobs get `source: "http" | "file"`, plus `startedAt`/`finishedAt` and file metadata (target fragment, snippet).
- **Watcher**: poll or watch `debug.js` for changes, parse request shape (first comment line + following JS). If a job is running, ignore until completion.
- **Dispatch hook**: when a page polls and receives a file job, mark `startedAt`, pin the executing header line, and write the acknowledgement body.
- **Result hook**: on page POST, compute duration and write back success (`var result = ...`) or error (raw stack) and update the header to the completed state.
- **Duration surfacing**: Always include "completed in/failed after <ms>ms" in the header. This timing is mandatory for actor verification; if timing cannot be computed, surface an explicit "duration unavailable" error.
- **Header writer**: periodic header-only rewrite with executing/last-completed line pinned first and other pages sorted by last heartbeat.

## Tips

- Create an IIFE that returns a value; avoid top-level `return`/`await`.
- Use `import()` with cache busting for iterative scripts, e.g., `await import('./x.js?' + Date.now())`.
- For non-serializable results, return a descriptive string.
- Always check and record the "completed in/failed after" duration for every REPL eval (compare across runs to catch regressions).

By making edits to debug.js file a helpful assistant can debug and profile the code in the browser completely autonomously. A helpful assistant must always attempt to work out the issues without user help before reporting errors or requesting user input.

## Relationship to HTTP REPL

The file-based REPL is an additive pathway to the existing HTTP REPL (`docs/7-http-test-harness.md`). Both share the same page registry, formatting of responses, and execution engine, differing only in how jobs are queued and where results are surfaced. Especially for file-based REPL, the actor must check the time spent in execution for every REPL eval.

## Numerical values

For milliseconds use toLocalString() to ensure 1200ms formatted with thousand separators such as 1,200 or 1 200 depending on the runtime environment.

## Format conformance

Update the HTTP flow to match the formats where necessary, including surfacing the "completed in/failed after" duration and requiring the actor to check it.
