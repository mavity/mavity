# File-based REPL Harness (debug.js)

This document specifies a file-based REPL mode that complements the existing HTTP REPL described in `docs/7-http-test-harness.md`. The goal is to allow a local debugging workflow using a single file in the repo root: `debug.js`.

The file protocol enables a tight request–ack–result loop via `serve.js` while keeping output tidy, minimal, and human-readable.

## Overview

- **Transport**: a local file `debug.js` at repo root (same directory as `serve.js`).
- **Initiation**: the debug actor edits `debug.js` to request running a script in a chosen page.
- **Orchestration**: `serve.js` watches `debug.js`, acknowledges requests immediately, dispatches code to the matching page, and writes back the result or error.
- **Header**: `serve.js` always maintains a concise header at the top of `debug.js` listing known pages and their states.
- **Coexistence**: This runs alongside the HTTP-based REPL; both can be used concurrently.
- **Verification**: Every REPL eval must have its execution time checked by the actor. Treat duration as a required signal for debugging and performance tracking.

> Assume `serve.js` is already running at `http://localhost:8302/` and pages are open. No need to start/stop the server.

## File Protocol Shapes

At any time, the top of `debug.js` contains a header block of comment lines (read-only from the actor’s perspective) maintained by `serve.js`. The body below it depends on the current stage.

### 1) Idle (no request in flight)

```
// <page-name> <URL> <HH:MM:SS> idle
// <page-name> <URL> <HH:MM:SS> idle
// <page-name> <URL> <HH:MM:SS> idle
```

Notes:

- **Sorting**: by most recent heartbeat (`last`), unless there is an executing or last-completed page to pin at the top (see below).
- `HH:MM:SS` shows the page’s last poll time.

### 2) Request (debug actor writes a script)

```
// <page name or fragment>
<raw JavaScript to evaluate>
```

Rules:

- The first non-empty line must be a single-line comment naming the target page (partial match permitted; first match wins, same as HTTP REPL `name` fragment).
- Everything after the first line is raw JavaScript (expression or IIFE). Promises are awaited; return values are serialized to JSON, falling back to `String(value)` if not serializable.
- Save the file to submit the request.

### 3) Acknowledge (serve.js rewrites immediately)

```
// <executing-page> <URL> <HH:MM:SS> executing "<first 50 chars of code, newlines→space, … if long>" job=<id> started=<HH:MM:SS>
// <other-page> <URL> <HH:MM:SS>  <state>
// <other-page> <URL> <HH:MM:SS> <state>
```

Notes:

- The executing page is always pinned as the first header line while running.
- The code snippet is truncated to 50 visible characters, with `\n` replaced by a single space and an ellipsis if truncated.
- Job id and timestamp of start at the end of the line.

### 4) Success (result written back)

```
// <page> <URL> <HH:MM:SS> completed in <ms>ms (see below)
// <other-page> <URL> <HH:MM:SS> <state>
// <other-page> <URL> <HH:MM:SS> <state>
var result = <JSON-serialized result or String(value)>
```

Notes:

- The just-completed page remains pinned as the first header line (state: completed ok) until a new request is issued.
- The body contains a single `var result = ...` assignment without any trailing semicolon
- The assignment is the JSON formatted in multiple lines with 2-space indent
- The actor MUST check the execution time reported in the header for this REPL eval.

### 5) Error (stack verbatim)

```
// <page> <URL> <HH:MM:SS> failed after <ms>ms (see below)
// <other-page> <URL> <HH:MM:SS> <state>
// <other-page> <URL> <HH:MM:SS> <state>
<error stack verbatim, not JS>
```

Notes:

- The body is the raw error message/stack (no JS fencing or quoting), followed by finish info.
- The actor MUST check the "failed after <ms>ms" time in the header for this REPL eval.

### 6) Post-completion polling

- The completed header line stays as-is (not wiped back to idle) until the actor writes a new request for any of the pages. Any new page execution request resets residual states to idle and wipes their results from the body below.
- All pages continue polling; their `last` timestamps in the header keep updating on a periodic refresh.
- The body (result or stack) stays until overwritten by the next REPL eval request.

## Header Format and Ordering

- Pattern:
  - Executing: `// <name> <URL> <HH:MM:SS> executing "<snippet>" job=<id> started=<HH:MM:SS>`
  - Completed OK: `// <name> <URL> <HH:MM:SS> completed in <ms>ms (result below)`
  - Completed Error: `// <page> <URL> <HH:MM:SS> failed after <ms>ms (see below)`
  - Idle: `// <name> <URL> <HH:MM:SS> idle`
- **Pinned first line**:
  - If executing: the executing page is first.
  - Else if last-completed exists: that page is first (completed/failed).
  - Remaining lines sorted by most recent `last` timestamp.
- **Refresh cadence**: header is refreshed (e.g., ~1s) only when the header content actually changes, to minimize churn.

## Timing and Durations

- `startedAt`: when the page fetches the job (dispatch time).
- `finishedAt`: when the page posts the result/error.
- `duration = finishedAt - startedAt` displayed:
  - In header as `(<ms>ms)` or `(<X.Ys>)` when helpful.
    Header times show the page’s last heartbeat as `HH:MM:SS`.
- Requirement: For every REPL eval, the actor must check the measured execution time. Missing or anomalous durations should be treated as an error and investigated.

## Examples

### Idle header

```
// index-7-zen-12:01:03 http://localhost:8302/index 09:33:25 idle
// simplistic-5-nova-09:12:45 http://localhost:8302/simplistic 09:33:23 idle
// texture-11-echo-13:22:55 http://localhost:8302/texture 09:32:58 idle
```

Reminder: When you trigger a REPL eval from idle, check the execution time reported in the header upon completion.

### Request (actor writes)

```javascript
// index
(async () => {
  window.setMethod && window.setMethod("spectral");
  return "ok";
})();
```

Reminder: After submitting a REPL eval, plan to verify the time spent in execution when the result is written back.

### Acknowledge (serve.js rewrites)

```
// index-7-zen-12:01:03 http://localhost:8302/index 09:34:01 executing "(async () => { window setMethod && window..." job=12 started=09:34:01
// simplistic-5-nova-09:12:45 http://localhost:8302/simplistic 09:33:58 idle
// texture-11-echo-13:22:55 http://localhost:8302/texture 09:33:56 idle
```

Reminder: Once execution completes, check the reported duration ("completed in ..." or "failed after ...").

### Success (serve.js rewrites)

```
// index-7-zen-12:01:03 http://localhost:8302/index 09:34:02 completed in 742ms (result below)
var result = {
  "message": "ok"
}
```

Reminder: Verify and note the "completed in ..." time for this REPL eval.

### Error (serve.js rewrites)

```
// index-7-zen-12:01:03 http://localhost:8302/index 09:34:10 failed after 1,220ms (see below)
TypeError: Cannot read properties of undefined (reading 'fft')
    at <stack...>
    ...
```

Reminder: Verify and note the "failed after ..." time for this REPL eval.

## Concurrency and Safety

- **Single file job at a time**: while a file job is executing, new requests are ignored until completion. Submit the next request after the previous one completes.
- **Name matching**: partial match; first match wins (same semantics as HTTP REPL). Use distinctive titles to generate unique tab names.
- **Page not found**: `serve.js` rewrites header and body with `// page not found for "<fragment>"` and leaves the state idle.
- **Timeouts**: if no result within the server timeout (default 60s), header shows `completed error (timeout)`, body is `timeout` plus finish info.
- **Debounce and self-writes**: `serve.js` debounces reads and ignores its own write events to avoid feedback loops in editors.

## Implementation Notes (serve.js)

The following additions integrate file-based REPL without altering HTTP behavior:

- **Paths & constants**: `debug.js` path, snippet length (50), header refresh cadence (~1s), read debounce (~150ms).
- **Job model**: jobs get `source: "http" | "file"`, plus `startedAt`/`finishedAt` and file metadata (target fragment, snippet).
- **Watcher**: poll or watch `debug.js` for changes, parse request shape (first comment line + following JS). If a job is running, ignore until completion.
- **Dispatch hook**: when a page polls and receives a file job, mark `startedAt`, pin the executing header line, and write the acknowledgement body.
- **Result hook**: on page POST, compute duration and write back success (`var result = ...`) or error (raw stack) and update the header to the completed state.
- **Duration surfacing**: Always include "completed in/failed after <ms>ms" in the header. This timing is mandatory for actor verification; if timing cannot be computed, surface an explicit "duration unavailable" error.
- **Header writer**: periodic header-only rewrite with executing/last-completed line pinned first and other pages sorted by last heartbeat.

## Tips

- Write an IIFE that returns a value; avoid top-level `return`/`await`.
- Use `import()` with cache busting for iterative scripts, e.g., `await import('./x.js?' + Date.now())`.
- For non-serializable results, return a descriptive string.
- Always check and record the "completed in/failed after" duration for every REPL eval (compare across runs to catch regressions).

## Relationship to HTTP REPL

The file-based REPL is an additive pathway to the existing HTTP REPL (`docs/7-http-test-harness.md`). Both share the same page registry, formatting of responses, and execution engine, differing only in how jobs are queued and where results are surfaced. Especially for file-based REPL, the actor must check the time spent in execution for every REPL eval.

## Numerical values

For milliseconds use toLocalString() to ensure 1200ms formatted with thousand separators such as 1,200 or 1 200 depending on the runtime environment.

## Format conformance

Update the HTTP flow to match the formats where necessary, including surfacing the "completed in/failed after" duration and requiring the actor to check it.
