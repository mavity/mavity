# Quadrupole pyramid sibling omission

## Summary
- **Problem** Barns–Hut traversal in `particle-system/shaders/traversal-quadrupole.frag.js` and the monopole fallback in `particle-system/shaders/traversal.frag.js` skip the aggregated parent voxel (`dx = dy = dz = 0`) while descending, so mass located in the same parent but outside the current child voxel is never accumulated.
- **Symptom** Particles underestimate attraction from nearby clusters, especially where multiple voxels share a parent, producing asymmetric acceleration, energy drift, and visually “hollow” structures.

## Repercussions
- **Force underestimation** Local siblings are ignored until the traversal reaches L0, so any mass stored in higher levels (e.g. L1–L3) is invisible to the particle when MAC rejects the coarse cell. This weakens gravity in dense regions and breaks the accuracy promised by the quadrupole expansion.
- **Integration instability** The KDK integrator in `particle-system/particle-system-quadrupole.js` assumes consistent force magnitudes between frames. Missing sibling contributions cause frame-to-frame variance, increasing damping artifacts and degrading long-term orbit stability.
- **Debug tooling ambiguity** Metrics gathered via `particle-system/pm-debug/metrics.js` will misreport quadrupole vs monopole error because the discrepancy stems from traversal logic, not the multipole math.

## Root cause
- **Traversal skip** In both traversal shaders, the neighbor sweep (`for dx/dy/dz = -1…1`) explicitly continues when `(dx,dy,dz) == (0,0,0)`.
- **No sibling reconciliation** There is no follow-up pass to re-introduce the parent mass minus the child occupancy, so siblings inside the same parent voxel are forever omitted once the loop skips the center cell.

## Proposed fix
- **Sibling extraction** When iterating a level ≥ 1, sample the parent voxel (`neighborVoxel == myVoxel`) after the main loop, compute `A0_parent - A0_child`, `A1_parent - A1_child`, and `A2_parent - A2_child`, and accumulate the residual mass/moments using the same MAC test. This keeps the child’s self-mass excluded while restoring siblings.
- **Quadrupole parity** Mirror the subtraction for quadrupole tensors in `traversal-quadrupole.frag.js` so the residual’s monopole, dipole, and quadrupole terms remain consistent. Ensure `computeQuadrupoleAcceleration()` receives the residual values.
- **Monopole fallback** Apply the same residual logic in `traversal.frag.js` so the non-plan-C path maintains identical physics.
- **Occupancy masks** Extend `particle-system/shaders/traversal-quadrupole.frag.js` occupancy-mask path to treat the parent residual as occupied when any sibling bit is set, or fetch the mask first to short-circuit if only the current child is populated.
- **Testing** Add regression scenarios in `particle-system/pm-debug/` replay data that place two voxels inside one parent and verify the combined attraction matches direct-sum reference.

## Code areas to change
- **Traversal shaders** `particle-system/shaders/traversal-quadrupole.frag.js` and `particle-system/shaders/traversal.frag.js` – add sibling-residual sampling and accumulation.
- **CPU driver** `particle-system/pipeline/traversal.js` – ensure any new uniforms (e.g. residual toggles or parent grid data) are bound and that MAC thresholds remain aligned.
- **Pyramid data** `particle-system/pipeline/pyramid.js` – confirm reduction outputs remain accessible for parent sampling; may need helper to fetch parent texel coordinates from child indices efficiently.
- **Debug harness** `particle-system/pm-debug/metrics.js` and shader replay tooling – update expectations to include sibling contributions when comparing against CPU validation.

## Follow-up validation
- **Shader unit tests** Re-run GLSL unit harness described in `docs/0.1-unit-testing-glsl.md` for traversal shaders with scenarios that exercise sibling accumulation.
- **Performance audit** Profile additional sampling cost via `GPUProfiler` hooks to verify residual logic does not exceed current frame budget.
- **Visual confirmation** Use `particle-system/pm-debug` overlays to compare force fields before/after fix and ensure near-field gradients become smooth around dense clusters.