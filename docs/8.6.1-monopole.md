# Monopole Integration Tests — Practical Implementation Plan

## Overview

This document outlines the practical implementation of integration tests for the monopole particle system. Each test file is self-contained and creates its own GL context, ensuring isolation and debuggability.

## Test File: monopole.small-scale.test.js

### Purpose
Validate basic correctness on minimal particle configurations where behavior is predictable and hand-verifiable.

### Simplest Test: Single Particle at Rest

**What it does:**
- Create canvas and GL context
- Initialize monopole system with 1 particle at origin, zero velocity, mass 1.0
- Step simulation 10 times
- Verify particle remains at origin (no self-force)
- Verify velocity remains zero
- Dispose system and tear down GL context

**Utilities needed:**
- `createTestCanvas()` — creates offscreen canvas with WebGL2
- `readParticleData(system, particleIndex)` — reads position and velocity for one particle
- `assertVector3Near(actual, expected, tolerance)` — vector comparison with tolerance
- `disposeSystem(system)` — calls dispose and nullifies references

**Code structure:**
```
test('single particle at rest remains stationary')
  setup: canvas, gl, system with 1 particle
  action: step 10 times
  verify: position unchanged, velocity zero
  teardown: dispose system, remove canvas
```

**Estimated LOC:** 40-50 lines (including setup/teardown boilerplate)

### Other Tests in This File

**Two particles attract (2 particles, equal mass, separation 2.0):**
- Verify they move toward each other
- Check acceleration direction points toward other particle
- Validate force magnitude approximately matches 1/r² law
- **Differs by:** adding second particle, checking mutual motion, force calculation
- **Estimated LOC:** 50-60 lines

**Three-body Lagrange L4 (equilateral triangle, circular orbit):**
- Three equal masses in equilateral configuration
- Initial velocities for stable L4 orbit
- Verify triangle shape maintained over 100 steps
- Check angular momentum conservation (approximate)
- **Differs by:** 3 particles, geometric validation, rotational dynamics
- **Estimated LOC:** 70-80 lines

**Ten particles in cluster (random positions in small sphere):**
- 10 particles, random positions within radius 1.0, zero initial velocity
- Step 50 times, verify system contracts (net inward motion)
- Check no NaN or Inf in positions/velocities
- Verify center of mass motion is minimal (no external forces)
- **Differs by:** more particles, statistical checks, stability validation
- **Estimated LOC:** 60-70 lines

**Empty system (zero particles):**
- Initialize with empty particle arrays
- Verify step() doesn't crash
- Verify no GL errors
- **Differs by:** edge case handling, minimal validation
- **Estimated LOC:** 30-40 lines

### File Total: 5 tests, ~250-300 LOC

---

## Test File: monopole.large-scale.test.js

### Purpose
Validate scaling behavior and numerical stability with realistic particle counts.

### Simplest Test: 100 Particles Uniform Distribution

**What it does:**
- Create 100 particles uniformly distributed in cube [-4, 4]³
- Random unit mass, zero initial velocity
- Step 100 times
- Verify all positions finite (no divergence)
- Verify all velocities finite and bounded (< 10.0)
- Check center of mass drift is small (< 0.1)
- Check momentum conservation (< 1e-6 per step)

**Utilities needed:**
- `generateUniformParticles(count, bounds, seed)` — creates random uniform distribution
- `readAllParticleData(system)` — reads positions and velocities for all particles
- `computeCenterOfMass(positions, masses)` — calculates COM
- `computeTotalMomentum(velocities, masses)` — calculates total momentum
- `assertAllFinite(array)` — checks no NaN/Inf
- `assertBounded(array, maxValue)` — checks all values within bound

**Code structure:**
```
test('100 particles remain stable over 100 steps')
  setup: canvas, gl, 100 uniform particles
  initial: record COM, momentum
  action: step 100 times
  verify: all finite, velocities bounded, COM drift small, momentum conserved
  teardown: dispose, cleanup
```

**Estimated LOC:** 60-70 lines

### Other Tests in This File

**1000 particles clustered (Plummer-like initial conditions):**
- 1000 particles in clustered distribution (dense center, sparse edges)
- Step 200 times
- Verify system remains bound (no escape velocity)
- Check velocity dispersion increases slightly (virial equilibrium approach)
- Validate no numerical artifacts in dense regions
- **Differs by:** more particles, clustered geometry, physical behavior checks
- **Estimated LOC:** 70-80 lines

**10,000 particles with hierarchy (small dense core + diffuse halo):**
- 100 particles in dense core (radius 1.0), 9,900 in halo (radius 10.0)
- Different mass ranges (core: 10.0, halo: 1.0)
- Step 100 times
- Verify hierarchical structure maintained (no artificial mixing)
- Check performance doesn't degrade catastrophically
- Validate octree correctly handles density gradient
- **Differs by:** mass hierarchy, density gradient, octree stress test
- **Estimated LOC:** 80-90 lines

### File Total: 3 tests, ~210-240 LOC

---

## Test File: monopole.known-solutions.test.js

### Purpose
Validate against analytical solutions where exact behavior is known.

### Simplest Test: Binary Orbit (Circular)

**What it does:**
- Two equal masses (1.0 each) at positions [−1, 0, 0] and [+1, 0, 0] (separation 2.0)
- Center of mass at origin
- Calculate required circular orbit velocity: v = √(G(m1+m2)/(4a)) for each particle (perpendicular to separation)
- Initial velocities: particle 1 at [0, v, 0], particle 2 at [0, −v, 0] (opposite perpendicular directions)
- Calculate expected orbital period T = 2π√(a³/G(m1+m2)) where a = 1.0
- Step simulation for 2 full orbits using small timesteps (dt = 0.01, total steps ≈ 200T)
- Sample positions every 0.1 T intervals
- Verify orbit remains circular (radius variance from center < 5%)
- Verify period matches analytical value (±5%)
- If test fails, dump full trajectory data for debugging

**Utilities needed:**
- `setupBinaryOrbit(mass1, mass2, separation, eccentricity)` — creates binary with correct initial conditions (positions and circular orbit velocities)
- `computeOrbitalElements(pos1, pos2, vel1, vel2)` — extracts semi-major axis, eccentricity, period from two-body state
- `sampleTrajectory(system, duration, interval, callback)` — runs simulation and captures snapshots at regular intervals
- `analyzeOrbitCircularity(snapshots)` — computes radius variance and reports deviations
- `dumpTrajectoryDiagnostics(snapshots, expected)` — writes detailed failure data (all positions, velocities, computed elements)

**Code structure:**
```
test('binary orbit: circular case')
  setup: canvas, gl, binary system with circular orbit
  compute: expected period from analytical formula
  action: simulate 2 orbits, sample every 0.1 T
  verify: radius variance < 5%, period within 5%
  on failure: dump trajectory diagnostics
  teardown: dispose, cleanup
```

**Estimated LOC:** 90-110 lines (includes trajectory sampling and diagnostics)

### Other Tests in This File

**Solar system (8 planets + sun):**
- Initialize from JPL Horizons ephemeris (simplified: circular orbits)
- Step hourly for 1 year
- Aggregate daily positions
- Validate positions at 1 day, 1 week, 1 month, 3 months, 6 months, 1 year
- Single assertion with full diagnostic output
- Check inner planets (Mercury, Venus, Earth) more strictly than outer
- **Differs by:** 9 bodies, multi-timescale validation, mass hierarchy, diagnostic complexity
- **Estimated LOC:** 150-180 lines (includes ephemeris data, multi-scale validation)

**Plummer sphere equilibrium:**
- 1000 particles in Plummer sphere, virial equilibrium
- Evolve for 10 dynamical times
- Sample radial density profile at 3, 6, 10 dynamical times
- Verify profile matches Plummer formula (binned comparison)
- Check velocity dispersion remains constant (±10%)
- **Differs by:** statistical validation, density profile calculation, equilibrium checks
- **Estimated LOC:** 120-140 lines (includes profile binning, fitting)

### File Total: 3 tests, ~360-430 LOC

---

## Test File: monopole.conservation.test.js

### Purpose
Validate approximate conservation laws over extended simulation periods.

### Simplest Test: Momentum Conservation (No External Forces)

**What it does:**
- 10 particles, random positions and velocities
- Initial total momentum P₀ = Σ(mᵢvᵢ)
- Step 1000 times
- Sample total momentum every 100 steps
- Verify momentum drift |P(t) - P₀| / |P₀| < 0.01 for all samples
- Check drift doesn't grow linearly (numerical stability)

**Utilities needed:**
- `generateRandomParticles(count, bounds, velocityScale, seed)` — creates random configuration
- `computeMomentumDrift(initialMomentum, currentMomentum)` — relative error calculation
- `assertConservationBounds(samples, tolerance)` — checks all samples within bound

**Code structure:**
```
test('total momentum conserved over 1000 steps')
  setup: canvas, gl, 10 random particles
  initial: compute P₀
  action: step 1000 times, sample momentum every 100 steps
  verify: all samples within 1% of P₀
  teardown: dispose, cleanup
```

**Estimated LOC:** 50-60 lines

### Other Tests in This File

**Angular momentum conservation (symmetric initial conditions):**
- 20 particles in spherically symmetric distribution
- Rotating about z-axis with solid-body rotation
- Initial angular momentum L₀
- Step 1000 times, sample every 100 steps
- Verify L(t) remains within 1% of L₀
- Check no precession (Lx, Ly remain near zero)
- **Differs by:** rotational setup, angular momentum calculation, axis stability
- **Estimated LOC:** 60-70 lines

**Energy conservation (isolated system with softening):**
- 50 particles, bound configuration
- Calculate E₀ = KE + PE with softening
- Step 1000 times, sample every 100 steps
- Verify energy drift < 5% (looser tolerance due to softening and time integration)
- Plot energy trend to diagnose if drift is systematic or oscillatory
- **Differs by:** energy calculation (KE + PE), potential energy with softening, looser tolerance
- **Estimated LOC:** 70-80 lines

### File Total: 3 tests, ~180-210 LOC

---

## Test File: monopole.stability.test.js

### Purpose
Validate numerical stability under extreme conditions and edge cases.

### Simplest Test: Long Integration (10,000 Steps)

**What it does:**
- 20 particles, bound configuration (cluster)
- Step 10,000 times
- Check every 1000 steps: all positions/velocities finite, no runaway particles
- Verify system remains bound (no particle farther than 2× initial radius)
- Check simulation time doesn't degrade (first 1000 steps vs last 1000 steps)

**Utilities needed:**
- `assertSystemBounded(positions, maxRadius)` — checks no escaping particles
- `computeSystemRadius(positions)` — maximum distance from origin
- `measureStepTime(system, steps)` — times execution of N steps

**Code structure:**
```
test('system stable over 10,000 steps')
  setup: canvas, gl, 20 particle cluster
  initial: record max radius
  action: step 10,000 times with periodic checks
  verify: all finite, system bounded, no performance degradation
  teardown: dispose, cleanup
```

**Estimated LOC:** 60-70 lines

### Other Tests in This File

**Close encounters (two particles with impact parameter):**
- 2 particles on near-collision trajectory
- Softening length ε = 0.1
- Step through encounter (closest approach ~ε)
- Verify no NaN/Inf at closest approach
- Check particles deflect correctly (scattering angle)
- Validate softening prevents divergence
- **Differs by:** specific geometry, softening validation, scattering physics
- **Estimated LOC:** 70-80 lines

**Extreme mass ratios (1:1000):**
- 1 massive particle (mass 1000) at center
- 10 light particles (mass 1.0) in orbit
- Step 500 times
- Verify light particles don't numerically dominate
- Check massive particle barely moves
- Validate forces on light particles correct
- **Differs by:** mass hierarchy, force asymmetry checks
- **Estimated LOC:** 60-70 lines

**Boundary stress (particles near world limits):**
- 10 particles near worldBounds edges
- Step 200 times
- Verify no issues with boundary conditions
- Check octree handles edge particles correctly
- Validate forces computed correctly near boundaries
- **Differs by:** spatial configuration, boundary condition checks
- **Estimated LOC:** 50-60 lines

### File Total: 4 tests, ~240-280 LOC

---

## Test File: monopole.convergence.test.js

### Purpose
Validate that refinement improves accuracy as expected.

### Simplest Test: Theta Parameter Convergence

**What it does:**
- Binary orbit configuration (known analytical solution)
- Run simulation 3 times with theta = 0.8, 0.5, 0.3
- For each run: simulate 100 steps, measure orbit error
- Verify error decreases monotonically: error(0.8) > error(0.5) > error(0.3)
- Check error reduction approximately matches expected rate

**Utilities needed:**
- `runWithParameters(particleData, params, steps)` — creates system, runs, returns results
- `computeOrbitError(trajectory, analyticalOrbit)` — RMS position error
- `assertMonotonicDecrease(values)` — checks values[i] > values[i+1]

**Code structure:**
```
test('theta parameter convergence')
  setup: define binary orbit scenario
  for each theta in [0.8, 0.5, 0.3]:
    create canvas, gl, system with theta
    run 100 steps, compute orbit error
    dispose system, cleanup
  verify: errors decrease monotonically
```

**Estimated LOC:** 70-80 lines

### Other Tests in This File

**Softening length convergence:**
- Close binary (separation 1.0)
- Run with softening ε = 0.2, 0.1, 0.05
- Compare force accuracy at fixed separation
- Verify force converges to 1/r² as ε → 0
- **Differs by:** parameter being varied, force accuracy metric
- **Estimated LOC:** 70-80 lines

**Near-field cutoff convergence:**
- Cluster of 50 particles
- Vary near-field cutoff radius
- Measure force accuracy in dense regions
- Verify accuracy improves with larger cutoff (up to a point)
- **Differs by:** near-field parameter, dense region focus
- **Estimated LOC:** 70-80 lines

### File Total: 3 tests, ~210-240 LOC

---

## Test File: monopole.resource-mgmt.test.js

### Purpose
Validate GPU resource lifecycle and memory management.

### Simplest Test: Create/Dispose Cycle

**What it does:**
- Loop 10 iterations:
  - Create canvas and GL context
  - Initialize monopole system with 100 particles
  - Step 10 times
  - Call system.dispose()
  - Remove canvas, lose GL context
- After all iterations:
  - Verify no accumulating memory leaks (check manually or with performance.memory)
  - Verify no GL context errors in any iteration

**Utilities needed:**
- `createIsolatedTest()` — creates canvas, returns cleanup function
- `checkGLErrors(gl)` — queries GL error state
- (Optional) `measureMemoryUsage()` — reads performance.memory if available

**Code structure:**
```
test('create and dispose 10 times without leaks')
  for i in 0..9:
    setup: canvas, gl, system
    action: step 10 times
    teardown: dispose, cleanup, check GL errors
  verify: no errors accumulated
```

**Estimated LOC:** 50-60 lines

### Other Tests in This File

**Texture reuse (externally managed textures):**
- Create position texture externally
- Create monopole system passing external texture as inPosition
- Null out system.inPosition before dispose()
- Call system.dispose()
- Verify external texture still valid (query GL, no error)
- Use external texture again in new system
- **Differs by:** external resource management, texture ownership validation
- **Estimated LOC:** 60-70 lines

### File Total: 2 tests, ~110-130 LOC

---

## Shared Utilities (test-utils-integration.js)

### Canvas and GL Management

**createTestCanvas(width, height):**
- Creates offscreen canvas (or detached DOM canvas)
- Returns canvas element
- ~10 LOC

**createGLContext(canvas):**
- Gets WebGL2 context with required extensions
- Checks EXT_color_buffer_float availability
- Returns gl or throws if unsupported
- ~15 LOC

**cleanupGL(canvas, gl):**
- Loses GL context if possible
- Removes canvas from DOM if attached
- ~5 LOC

### Particle Data Generation

**generateUniformParticles(count, bounds, seed):**
- Creates Float32Arrays for positions and velocities
- Random uniform distribution within bounds
- Uses seeded random for reproducibility
- Returns { positions, velocities, masses }
- ~30 LOC

**generateRandomParticles(count, bounds, velocityScale, seed):**
- Similar to uniform but with random velocities
- ~30 LOC

**setupBinaryOrbit(mass1, mass2, separation, eccentricity):**
- Calculates initial conditions for two-body orbit
- Returns particle data with correct velocities for stable orbit
- ~40 LOC

### Data Reading

**readParticleData(system, particleIndex):**
- Reads position and velocity from GPU textures
- Returns { position: [x,y,z,m], velocity: [vx,vy,vz,0] }
- ~25 LOC

**readAllParticleData(system):**
- Reads all particles
- Returns { positions: Float32Array, velocities: Float32Array }
- ~30 LOC

### Physics Calculations

**computeCenterOfMass(positions, masses):**
- Calculates weighted average position
- Returns [x, y, z]
- ~15 LOC

**computeTotalMomentum(velocities, masses):**
- Sums mᵢvᵢ
- Returns [px, py, pz]
- ~15 LOC

**computeAngularMomentum(positions, velocities, masses):**
- Computes Σ(rᵢ × mᵢvᵢ)
- Returns [Lx, Ly, Lz]
- ~20 LOC

**computeKineticEnergy(velocities, masses):**
- Sums ½mᵢvᵢ²
- Returns scalar
- ~10 LOC

**computePotentialEnergy(positions, masses, softening, gravityStrength):**
- Double loop over particle pairs
- Computes -G Σᵢ<ⱼ mᵢmⱼ / √(rᵢⱼ² + ε²)
- Returns scalar
- ~25 LOC

### Assertions

**assertVector3Near(actual, expected, tolerance, message):**
- Checks |actual - expected| < tolerance component-wise
- Throws with message if fails
- ~10 LOC

**assertAllFinite(array, message):**
- Checks no NaN or Inf in array
- ~10 LOC

**assertBounded(array, maxValue, message):**
- Checks all |values| < maxValue
- ~10 LOC

**assertMonotonicDecrease(values, message):**
- Checks values[i] > values[i+1]
- ~10 LOC

### Trajectory Sampling

**sampleTrajectory(system, duration, interval, callback):**
- Runs simulation, calls callback at regular intervals
- Callback receives current time and particle data
- Returns array of samples
- ~30 LOC

### Diagnostics

**dumpTrajectoryDiagnostics(snapshots, expected, outputPath):**
- Writes detailed failure data
- Console output or file if in Node
- ~40 LOC

### Total Utilities: ~400-450 LOC

---

## Summary Statistics

| File | Tests | Estimated LOC | Purpose |
|------|-------|---------------|---------|
| monopole.small-scale.test.js | 5 | 250-300 | Basic correctness |
| monopole.large-scale.test.js | 3 | 210-240 | Scaling validation |
| monopole.known-solutions.test.js | 3 | 360-430 | Analytical solutions |
| monopole.conservation.test.js | 3 | 180-210 | Physics invariants |
| monopole.stability.test.js | 4 | 240-280 | Extreme conditions |
| monopole.convergence.test.js | 3 | 210-240 | Refinement behavior |
| monopole.resource-mgmt.test.js | 2 | 110-130 | Memory lifecycle |
| **Total** | **23** | **1560-1830** | |
| test-utils-integration.js | N/A | 400-450 | Shared utilities |
| **Grand Total** | **23** | **1960-2280** | Complete test suite |

Each test is self-contained with its own GL context creation and teardown, ensuring isolation and debuggability. Tests avoid excessive sharing to maintain clarity and independence.
